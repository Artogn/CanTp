#define _CFFI_

/* We try to define Py_LIMITED_API before including Python.h.

   Mess: we can only define it if Py_DEBUG, Py_TRACE_REFS and
   Py_REF_DEBUG are not defined.  This is a best-effort approximation:
   we can learn about Py_DEBUG from pyconfig.h, but it is unclear if
   the same works for the other two macros.  Py_DEBUG implies them,
   but not the other way around.

   Issue #350 is still open: on Windows, the code here causes it to link
   with PYTHON36.DLL (for example) instead of PYTHON3.DLL.  A fix was
   attempted in 164e526a5515 and 14ce6985e1c3, but reverted: virtualenv
   does not make PYTHON3.DLL available, and so the "correctly" compiled
   version would not run inside a virtualenv.  We will re-apply the fix
   after virtualenv has been fixed for some time.  For explanation, see
   issue #355.  For a workaround if you want PYTHON3.DLL and don't worry
   about virtualenv, see issue #350.  See also 'py_limited_api' in
   setuptools_ext.py.
*/
#if !defined(_CFFI_USE_EMBEDDING) && !defined(Py_LIMITED_API)
#  include <pyconfig.h>
#  if !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG)
#    define Py_LIMITED_API
#  endif
#endif

#include <Python.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <stddef.h>

/* This part is from file 'cffi/parse_c_type.h'.  It is copied at the
   beginning of C sources generated by CFFI's ffi.set_source(). */

typedef void *_cffi_opcode_t;

#define _CFFI_OP(opcode, arg)   (_cffi_opcode_t)(opcode | (((uintptr_t)(arg)) << 8))
#define _CFFI_GETOP(cffi_opcode)    ((unsigned char)(uintptr_t)cffi_opcode)
#define _CFFI_GETARG(cffi_opcode)   (((intptr_t)cffi_opcode) >> 8)

#define _CFFI_OP_PRIMITIVE       1
#define _CFFI_OP_POINTER         3
#define _CFFI_OP_ARRAY           5
#define _CFFI_OP_OPEN_ARRAY      7
#define _CFFI_OP_STRUCT_UNION    9
#define _CFFI_OP_ENUM           11
#define _CFFI_OP_FUNCTION       13
#define _CFFI_OP_FUNCTION_END   15
#define _CFFI_OP_NOOP           17
#define _CFFI_OP_BITFIELD       19
#define _CFFI_OP_TYPENAME       21
#define _CFFI_OP_CPYTHON_BLTN_V 23   // varargs
#define _CFFI_OP_CPYTHON_BLTN_N 25   // noargs
#define _CFFI_OP_CPYTHON_BLTN_O 27   // O  (i.e. a single arg)
#define _CFFI_OP_CONSTANT       29
#define _CFFI_OP_CONSTANT_INT   31
#define _CFFI_OP_GLOBAL_VAR     33
#define _CFFI_OP_DLOPEN_FUNC    35
#define _CFFI_OP_DLOPEN_CONST   37
#define _CFFI_OP_GLOBAL_VAR_F   39
#define _CFFI_OP_EXTERN_PYTHON  41

#define _CFFI_PRIM_VOID          0
#define _CFFI_PRIM_BOOL          1
#define _CFFI_PRIM_CHAR          2
#define _CFFI_PRIM_SCHAR         3
#define _CFFI_PRIM_UCHAR         4
#define _CFFI_PRIM_SHORT         5
#define _CFFI_PRIM_USHORT        6
#define _CFFI_PRIM_INT           7
#define _CFFI_PRIM_UINT          8
#define _CFFI_PRIM_LONG          9
#define _CFFI_PRIM_ULONG        10
#define _CFFI_PRIM_LONGLONG     11
#define _CFFI_PRIM_ULONGLONG    12
#define _CFFI_PRIM_FLOAT        13
#define _CFFI_PRIM_DOUBLE       14
#define _CFFI_PRIM_LONGDOUBLE   15

#define _CFFI_PRIM_WCHAR        16
#define _CFFI_PRIM_INT8         17
#define _CFFI_PRIM_UINT8        18
#define _CFFI_PRIM_INT16        19
#define _CFFI_PRIM_UINT16       20
#define _CFFI_PRIM_INT32        21
#define _CFFI_PRIM_UINT32       22
#define _CFFI_PRIM_INT64        23
#define _CFFI_PRIM_UINT64       24
#define _CFFI_PRIM_INTPTR       25
#define _CFFI_PRIM_UINTPTR      26
#define _CFFI_PRIM_PTRDIFF      27
#define _CFFI_PRIM_SIZE         28
#define _CFFI_PRIM_SSIZE        29
#define _CFFI_PRIM_INT_LEAST8   30
#define _CFFI_PRIM_UINT_LEAST8  31
#define _CFFI_PRIM_INT_LEAST16  32
#define _CFFI_PRIM_UINT_LEAST16 33
#define _CFFI_PRIM_INT_LEAST32  34
#define _CFFI_PRIM_UINT_LEAST32 35
#define _CFFI_PRIM_INT_LEAST64  36
#define _CFFI_PRIM_UINT_LEAST64 37
#define _CFFI_PRIM_INT_FAST8    38
#define _CFFI_PRIM_UINT_FAST8   39
#define _CFFI_PRIM_INT_FAST16   40
#define _CFFI_PRIM_UINT_FAST16  41
#define _CFFI_PRIM_INT_FAST32   42
#define _CFFI_PRIM_UINT_FAST32  43
#define _CFFI_PRIM_INT_FAST64   44
#define _CFFI_PRIM_UINT_FAST64  45
#define _CFFI_PRIM_INTMAX       46
#define _CFFI_PRIM_UINTMAX      47
#define _CFFI_PRIM_FLOATCOMPLEX 48
#define _CFFI_PRIM_DOUBLECOMPLEX 49
#define _CFFI_PRIM_CHAR16       50
#define _CFFI_PRIM_CHAR32       51

#define _CFFI__NUM_PRIM         52
#define _CFFI__UNKNOWN_PRIM           (-1)
#define _CFFI__UNKNOWN_FLOAT_PRIM     (-2)
#define _CFFI__UNKNOWN_LONG_DOUBLE    (-3)

#define _CFFI__IO_FILE_STRUCT         (-1)


struct _cffi_global_s {
    const char *name;
    void *address;
    _cffi_opcode_t type_op;
    void *size_or_direct_fn;  // OP_GLOBAL_VAR: size, or 0 if unknown
                              // OP_CPYTHON_BLTN_*: addr of direct function
};

struct _cffi_getconst_s {
    unsigned long long value;
    const struct _cffi_type_context_s *ctx;
    int gindex;
};

struct _cffi_struct_union_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_STRUCT_UNION
    int flags;               // _CFFI_F_* flags below
    size_t size;
    int alignment;
    int first_field_index;   // -> _cffi_fields array
    int num_fields;
};
#define _CFFI_F_UNION         0x01   // is a union, not a struct
#define _CFFI_F_CHECK_FIELDS  0x02   // complain if fields are not in the
                                     // "standard layout" or if some are missing
#define _CFFI_F_PACKED        0x04   // for CHECK_FIELDS, assume a packed struct
#define _CFFI_F_EXTERNAL      0x08   // in some other ffi.include()
#define _CFFI_F_OPAQUE        0x10   // opaque

struct _cffi_field_s {
    const char *name;
    size_t field_offset;
    size_t field_size;
    _cffi_opcode_t field_type_op;
};

struct _cffi_enum_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_ENUM
    int type_prim;           // _CFFI_PRIM_xxx
    const char *enumerators; // comma-delimited string
};

struct _cffi_typename_s {
    const char *name;
    int type_index;   /* if opaque, points to a possibly artificial
                         OP_STRUCT which is itself opaque */
};

struct _cffi_type_context_s {
    _cffi_opcode_t *types;
    const struct _cffi_global_s *globals;
    const struct _cffi_field_s *fields;
    const struct _cffi_struct_union_s *struct_unions;
    const struct _cffi_enum_s *enums;
    const struct _cffi_typename_s *typenames;
    int num_globals;
    int num_struct_unions;
    int num_enums;
    int num_typenames;
    const char *const *includes;
    int num_types;
    int flags;      /* future extension */
};

struct _cffi_parse_info_s {
    const struct _cffi_type_context_s *ctx;
    _cffi_opcode_t *output;
    unsigned int output_size;
    size_t error_location;
    const char *error_message;
};

struct _cffi_externpy_s {
    const char *name;
    size_t size_of_result;
    void *reserved1, *reserved2;
};

#ifdef _CFFI_INTERNAL
static int parse_c_type(struct _cffi_parse_info_s *info, const char *input);
static int search_in_globals(const struct _cffi_type_context_s *ctx,
                             const char *search, size_t search_len);
static int search_in_struct_unions(const struct _cffi_type_context_s *ctx,
                                   const char *search, size_t search_len);
#endif

/* this block of #ifs should be kept exactly identical between
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py
   and cffi/_cffi_include.h */
#if defined(_MSC_VER)
# include <malloc.h>   /* for alloca() */
# if _MSC_VER < 1600   /* MSVC < 2010 */
   typedef __int8 int8_t;
   typedef __int16 int16_t;
   typedef __int32 int32_t;
   typedef __int64 int64_t;
   typedef unsigned __int8 uint8_t;
   typedef unsigned __int16 uint16_t;
   typedef unsigned __int32 uint32_t;
   typedef unsigned __int64 uint64_t;
   typedef __int8 int_least8_t;
   typedef __int16 int_least16_t;
   typedef __int32 int_least32_t;
   typedef __int64 int_least64_t;
   typedef unsigned __int8 uint_least8_t;
   typedef unsigned __int16 uint_least16_t;
   typedef unsigned __int32 uint_least32_t;
   typedef unsigned __int64 uint_least64_t;
   typedef __int8 int_fast8_t;
   typedef __int16 int_fast16_t;
   typedef __int32 int_fast32_t;
   typedef __int64 int_fast64_t;
   typedef unsigned __int8 uint_fast8_t;
   typedef unsigned __int16 uint_fast16_t;
   typedef unsigned __int32 uint_fast32_t;
   typedef unsigned __int64 uint_fast64_t;
   typedef __int64 intmax_t;
   typedef unsigned __int64 uintmax_t;
# else
#  include <stdint.h>
# endif
# if _MSC_VER < 1800   /* MSVC < 2013 */
#  ifndef __cplusplus
    typedef unsigned char _Bool;
#  endif
# endif
#else
# include <stdint.h>
# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)
#  include <alloca.h>
# endif
#endif

#ifdef __GNUC__
# define _CFFI_UNUSED_FN  __attribute__((unused))
#else
# define _CFFI_UNUSED_FN  /* nothing */
#endif

#ifdef __cplusplus
# ifndef _Bool
   typedef bool _Bool;   /* semi-hackish: C++ has no _Bool; bool is builtin */
# endif
#endif

/**********  CPython-specific section  **********/
#ifndef PYPY_VERSION


#if PY_MAJOR_VERSION >= 3
# define PyInt_FromLong PyLong_FromLong
#endif

#define _cffi_from_c_double PyFloat_FromDouble
#define _cffi_from_c_float PyFloat_FromDouble
#define _cffi_from_c_long PyInt_FromLong
#define _cffi_from_c_ulong PyLong_FromUnsignedLong
#define _cffi_from_c_longlong PyLong_FromLongLong
#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong
#define _cffi_from_c__Bool PyBool_FromLong

#define _cffi_to_c_double PyFloat_AsDouble
#define _cffi_to_c_float PyFloat_AsDouble

#define _cffi_from_c_int(x, type)                                        \
    (((type)-1) > 0 ? /* unsigned */                                     \
        (sizeof(type) < sizeof(long) ?                                   \
            PyInt_FromLong((long)x) :                                    \
         sizeof(type) == sizeof(long) ?                                  \
            PyLong_FromUnsignedLong((unsigned long)x) :                  \
            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \
        (sizeof(type) <= sizeof(long) ?                                  \
            PyInt_FromLong((long)x) :                                    \
            PyLong_FromLongLong((long long)x)))

#define _cffi_to_c_int(o, type)                                          \
    ((type)(                                                             \
     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \
                                         : (type)_cffi_to_c_i8(o)) :     \
     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \
                                         : (type)_cffi_to_c_i16(o)) :    \
     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \
                                         : (type)_cffi_to_c_i32(o)) :    \
     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \
                                         : (type)_cffi_to_c_i64(o)) :    \
     (Py_FatalError("unsupported size for type " #type), (type)0)))

#define _cffi_to_c_i8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[1])
#define _cffi_to_c_u8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[2])
#define _cffi_to_c_i16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[3])
#define _cffi_to_c_u16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[4])
#define _cffi_to_c_i32                                                   \
                 ((int(*)(PyObject *))_cffi_exports[5])
#define _cffi_to_c_u32                                                   \
                 ((unsigned int(*)(PyObject *))_cffi_exports[6])
#define _cffi_to_c_i64                                                   \
                 ((long long(*)(PyObject *))_cffi_exports[7])
#define _cffi_to_c_u64                                                   \
                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])
#define _cffi_to_c_char                                                  \
                 ((int(*)(PyObject *))_cffi_exports[9])
#define _cffi_from_c_pointer                                             \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[10])
#define _cffi_to_c_pointer                                               \
    ((char *(*)(PyObject *, struct _cffi_ctypedescr *))_cffi_exports[11])
#define _cffi_get_struct_layout                                          \
    not used any more
#define _cffi_restore_errno                                              \
    ((void(*)(void))_cffi_exports[13])
#define _cffi_save_errno                                                 \
    ((void(*)(void))_cffi_exports[14])
#define _cffi_from_c_char                                                \
    ((PyObject *(*)(char))_cffi_exports[15])
#define _cffi_from_c_deref                                               \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[16])
#define _cffi_to_c                                                       \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[17])
#define _cffi_from_c_struct                                              \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[18])
#define _cffi_to_c_wchar_t                                               \
    ((_cffi_wchar_t(*)(PyObject *))_cffi_exports[19])
#define _cffi_from_c_wchar_t                                             \
    ((PyObject *(*)(_cffi_wchar_t))_cffi_exports[20])
#define _cffi_to_c_long_double                                           \
    ((long double(*)(PyObject *))_cffi_exports[21])
#define _cffi_to_c__Bool                                                 \
    ((_Bool(*)(PyObject *))_cffi_exports[22])
#define _cffi_prepare_pointer_call_argument                              \
    ((Py_ssize_t(*)(struct _cffi_ctypedescr *,                           \
                    PyObject *, char **))_cffi_exports[23])
#define _cffi_convert_array_from_object                                  \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[24])
#define _CFFI_CPIDX  25
#define _cffi_call_python                                                \
    ((void(*)(struct _cffi_externpy_s *, char *))_cffi_exports[_CFFI_CPIDX])
#define _cffi_to_c_wchar3216_t                                           \
    ((int(*)(PyObject *))_cffi_exports[26])
#define _cffi_from_c_wchar3216_t                                         \
    ((PyObject *(*)(int))_cffi_exports[27])
#define _CFFI_NUM_EXPORTS 28

struct _cffi_ctypedescr;

static void *_cffi_exports[_CFFI_NUM_EXPORTS];

#define _cffi_type(index)   (                           \
    assert((((uintptr_t)_cffi_types[index]) & 1) == 0), \
    (struct _cffi_ctypedescr *)_cffi_types[index])

static PyObject *_cffi_init(const char *module_name, Py_ssize_t version,
                            const struct _cffi_type_context_s *ctx)
{
    PyObject *module, *o_arg, *new_module;
    void *raw[] = {
        (void *)module_name,
        (void *)version,
        (void *)_cffi_exports,
        (void *)ctx,
    };

    module = PyImport_ImportModule("_cffi_backend");
    if (module == NULL)
        goto failure;

    o_arg = PyLong_FromVoidPtr((void *)raw);
    if (o_arg == NULL)
        goto failure;

    new_module = PyObject_CallMethod(
        module, (char *)"_init_cffi_1_0_external_module", (char *)"O", o_arg);

    Py_DECREF(o_arg);
    Py_DECREF(module);
    return new_module;

  failure:
    Py_XDECREF(module);
    return NULL;
}


#ifdef HAVE_WCHAR_H
typedef wchar_t _cffi_wchar_t;
#else
typedef uint16_t _cffi_wchar_t;   /* same random pick as _cffi_backend.c */
#endif

_CFFI_UNUSED_FN static uint16_t _cffi_to_c_char16_t(PyObject *o)
{
    if (sizeof(_cffi_wchar_t) == 2)
        return (uint16_t)_cffi_to_c_wchar_t(o);
    else
        return (uint16_t)_cffi_to_c_wchar3216_t(o);
}

_CFFI_UNUSED_FN static PyObject *_cffi_from_c_char16_t(uint16_t x)
{
    if (sizeof(_cffi_wchar_t) == 2)
        return _cffi_from_c_wchar_t((_cffi_wchar_t)x);
    else
        return _cffi_from_c_wchar3216_t((int)x);
}

_CFFI_UNUSED_FN static int _cffi_to_c_char32_t(PyObject *o)
{
    if (sizeof(_cffi_wchar_t) == 4)
        return (int)_cffi_to_c_wchar_t(o);
    else
        return (int)_cffi_to_c_wchar3216_t(o);
}

_CFFI_UNUSED_FN static PyObject *_cffi_from_c_char32_t(int x)
{
    if (sizeof(_cffi_wchar_t) == 4)
        return _cffi_from_c_wchar_t((_cffi_wchar_t)x);
    else
        return _cffi_from_c_wchar3216_t(x);
}


/**********  end CPython-specific section  **********/
#else
_CFFI_UNUSED_FN
static void (*_cffi_call_python_org)(struct _cffi_externpy_s *, char *);
# define _cffi_call_python  _cffi_call_python_org
#endif


#define _cffi_array_len(array)   (sizeof(array) / sizeof((array)[0]))

#define _cffi_prim_int(size, sign)                                      \
    ((size) == 1 ? ((sign) ? _CFFI_PRIM_INT8  : _CFFI_PRIM_UINT8)  :    \
     (size) == 2 ? ((sign) ? _CFFI_PRIM_INT16 : _CFFI_PRIM_UINT16) :    \
     (size) == 4 ? ((sign) ? _CFFI_PRIM_INT32 : _CFFI_PRIM_UINT32) :    \
     (size) == 8 ? ((sign) ? _CFFI_PRIM_INT64 : _CFFI_PRIM_UINT64) :    \
     _CFFI__UNKNOWN_PRIM)

#define _cffi_prim_float(size)                                          \
    ((size) == sizeof(float) ? _CFFI_PRIM_FLOAT :                       \
     (size) == sizeof(double) ? _CFFI_PRIM_DOUBLE :                     \
     (size) == sizeof(long double) ? _CFFI__UNKNOWN_LONG_DOUBLE :       \
     _CFFI__UNKNOWN_FLOAT_PRIM)

#define _cffi_check_int(got, got_nonpos, expected)      \
    ((got_nonpos) == (expected <= 0) &&                 \
     (got) == (unsigned long long)expected)

#ifdef MS_WIN32
# define _cffi_stdcall  __stdcall
#else
# define _cffi_stdcall  /* nothing */
#endif

#ifdef __cplusplus
}
#endif

/************************************************************/

/**
 * @file CanTp.c
 * @author
 * @date
 *
 * @defgroup CANTP_C implementation
 * @ingroup CANTP
 *
 * @defgroup CANTP_C_LDEF local definitions
 * @ingroup CANTP_C
 * @defgroup CANTP_C_LTDEF local data type definitions
 * @ingroup CANTP_C
 * @defgroup CANTP_C_LMDEF local macros
 * @ingroup CANTP_C
 * @defgroup CANTP_C_LFDECL local function declarations
 * @ingroup CANTP_C
 * @defgroup CANTP_C_LCDEF local constant definitions
 * @ingroup CANTP_C
 * @defgroup CANTP_C_LVDEF local variable definitions
 * @ingroup CANTP_C
 * @defgroup CANTP_C_GCDEF global constant definitions
 * @ingroup CANTP_C
 * @defgroup CANTP_C_GVDEF global variable definitions
 * @ingroup CANTP_C
 * @defgroup CANTP_C_GFDEF global function definitions
 * @ingroup CANTP_C
 * @defgroup CANTP_C_GSFDEF global scheduled function definitions
 * @ingroup CANTP_C
 * @defgroup CANTP_C_GCFDEF global callback function definitions
 * @ingroup CANTP_C
 * @defgroup CANTP_C_LFDEF local function definitions
 * @ingroup CANTP_C
 */

/*-----------------------------------------------------------------------------------------------*/
/* included files (#include).                                                                    */
/*-----------------------------------------------------------------------------------------------*/

/**
 * @addtogroup CANTP_C
 * @{
 */

#ifdef __cplusplus

extern "C"
{

#endif /* ifdef __cplusplus */

#ifndef CANIF_H
#include "CanIf.h"
#endif /* #ifndef CANIF_H */

#include "CanTp.h"

#include "CanTp_Cfg.h"

#ifndef CANTP_CBK_H
#include "CanTp_Cbk.h"
#endif /* #ifndef CANTP_CBK_H */

#ifndef COMSTACK_TYPES_H
#include "ComStack_Types.h"
#endif /* #ifndef COMSTACK_TYPES_H */

#ifndef PDUR_H
#include "PduR.h"
#endif /* #ifndef PDUR_H */

#if (CANTP_DEV_ERROR_DETECT == STD_ON)

#ifndef DET_H
#include "Det.h"
#endif /* #ifndef DET_H */

#endif /* #if (CANTP_DEV_ERROR_DETECT == STD_ON) */

/** @} */


/*-----------------------------------------------------------------------------------------------*/
/* local definitions (#define).                                                                  */
/*-----------------------------------------------------------------------------------------------*/

/**
 * @addtogroup CANTP_C_LDEF
 * @{
 */


#define CANTP_N_PCI_TYPE_SF (0x00u)

#define CANTP_N_PCI_TYPE_FF (0x01u)

#define CANTP_N_PCI_TYPE_CF (0x02u)

#define CANTP_N_PCI_TYPE_FC (0x03u)

#define CANTP_FLOW_STATUS_TYPE_CTS (0x00u)

#define CANTP_FLOW_STATUS_TYPE_WT (0x01u)

#define CANTP_FLOW_STATUS_TYPE_OVFLW (0x02u)

#define CANTP_CAN_FRAME_SIZE (0x08u)

#define CANTP_SF_PCI_FIELD_SIZE (0x01u)

#define CANTP_FF_PCI_FIELD_SIZE (0x02u)

#define CANTP_CF_PCI_FIELD_SIZE (0x01u)

#define CANTP_BS_INFINITE (0x0100u)

#define CANTP_DIRECTION_RX (0x01u)

#define CANTP_DIRECTION_TX (0x02u)

/** @} */


/*-----------------------------------------------------------------------------------------------*/
/* local data type definitions (typedef, struct).                                                */
/*-----------------------------------------------------------------------------------------------*/

/**
 * @addtogroup CANTP_C_LTDEF
 * @{
 */

typedef uint8 CanTp_NPciType;

typedef uint8 CanTp_FlowStatusType;

typedef enum {
    CANTP_FRAME_STATE_INVALID = 0x00u,
    CANTP_RX_FRAME_STATE_FC_TX_REQUEST,
    CANTP_RX_FRAME_STATE_FC_TX_CONFIRMATION,
    CANTP_RX_FRAME_STATE_FC_OVFLW_TX_CONFIRMATION,
    CANTP_RX_FRAME_STATE_CF_RX_INDICATION,
    CANTP_TX_FRAME_STATE_SF_TX_REQUEST,
    CANTP_TX_FRAME_STATE_SF_TX_CONFIRMATION,
    CANTP_TX_FRAME_STATE_FF_TX_REQUEST,
    CANTP_TX_FRAME_STATE_FF_TX_CONFIRMATION,
    CANTP_TX_FRAME_STATE_CF_TX_REQUEST,
    CANTP_TX_FRAME_STATE_CF_TX_CONFIRMATION,
    CANTP_TX_FRAME_STATE_FC_RX_INDICATION,
    CANTP_FRAME_STATE_OK,
    CANTP_FRAME_STATE_ABORT
} CanTp_FrameStateType;

typedef enum
{
    CANTP_WAIT = 0x00u,
    CANTP_PROCESSING
} CanTp_TaskStateType;

typedef struct
{
    uint8 can[CANTP_CAN_FRAME_SIZE];
    PduLengthType size;
    PduLengthType rmng;
} CanTp_NSduBufferType;

typedef struct
{
    const CanTp_RxNSduType *cfg;
    CanTp_NSduBufferType buf;
    CanTp_FlowStatusType fs;
    uint32 st_min;
    uint8 bs;
    uint8 sn;
    uint16 wft_max;
    PduInfoType can_if_pdu_info;
    PduInfoType pdu_r_pdu_info;
    struct
    {
        CanTp_TaskStateType taskState;
        CanTp_FrameStateType state;

        /**
         * @brief structure containing all parameters accessible via @ref CanTp_ReadParameter/@ref
         * CanTp_ChangeParameter.
         */
        struct {
            uint16 st_min;
            uint8 bs;
        } m_param;
    } shared;
} CanTp_RxConnectionType;

typedef struct
{
    const CanTp_TxNSduType *cfg;
    CanTp_NSduBufferType buf;
    CanTp_FlowStatusType fs;
    uint32 target_st_min;
    uint32 st_min;
    uint16 bs;
    uint8 sn;
    PduInfoType can_if_pdu_info;
    CanTp_TaskStateType taskState;
    struct
    {
        CanTp_FrameStateType state;
        uint32 flag;
    } shared;
} CanTp_TxConnectionType;

typedef struct
{
    CanTp_RxConnectionType rx;
    CanTp_TxConnectionType tx;
    uint32 n[0x06u];
    uint8_least dir;
    uint32 t_flag;
} CanTp_NSduType;

typedef struct
{
    CanTp_NSduType sdu[CANTP_MAX_NUM_OF_N_SDU];
} CanTp_ChannelRtType;

/** @} */


/*-----------------------------------------------------------------------------------------------*/
/* local macros definitions (#define, inline).                                                   */
/*-----------------------------------------------------------------------------------------------*/

/**
 * @addtogroup CANTP_C_LMDEF
 * @{
 */

#ifndef CANTP_ENTER_CRITICAL_SECTION

#define CANTP_ENTER_CRITICAL_SECTION

#endif /* #ifndef CANTP_ENTER_CRITICAL_SECTION */

#ifndef CANTP_EXIT_CRITICAL_SECTION

#define CANTP_EXIT_CRITICAL_SECTION

#endif /* #ifndef CANTP_EXIT_CRITICAL_SECTION */

static inline uint32 CanTp_ConvertMsToUs(uint32 timeout)
{
    return timeout * 1000u;
}

static inline uint32 CanTp_ConvertUsToMs(uint32 timeout)
{
    return timeout / 1000u;
}

static inline uint32 CanTp_ConvertUsToUs(uint32 timeout)
{
    return timeout;
}

static inline void CanTp_ReportError(uint8 instanceId, uint8 apiId, uint8 errorId)
{
#if (CANTP_DEV_ERROR_DETECT == STD_ON)

    (void)Det_ReportError(CANTP_MODULE_ID, instanceId, apiId, errorId);

#else

    (void)instanceId;
    (void)apiId;
    (void)errorId;

#endif /* #if (CANTP_DEV_ERROR_DETECT == STD_ON) */
}

static inline void CanTp_ReportRuntimeError(uint8 instanceId, uint8 apiId, uint8 errorId)
{
#if (CANTP_DEV_ERROR_DETECT == STD_ON)

    (void)Det_ReportRuntimeError(CANTP_MODULE_ID, instanceId, apiId, errorId);

#else

    (void)instanceId;
    (void)apiId;
    (void)errorId;

#endif /* #if (CANTP_DEV_ERROR_DETECT == STD_ON) */
}

/** @} */


/*-----------------------------------------------------------------------------------------------*/
/* local function declarations (static).                                                         */
/*-----------------------------------------------------------------------------------------------*/

/**
 * @addtogroup CANTP_C_LFDECL
 * @{
 */

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static Std_ReturnType CanTp_GetNSduFromPduId(PduIdType pduId, CanTp_NSduType **pNSdu);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static PduLengthType CanTp_GetRxBlockSize(const CanTp_NSduType *pNSdu);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static Std_ReturnType CanTp_DecodeNAIValue(const CanTp_AddressingFormatType af,
                                           PduLengthType *pPduLength);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static Std_ReturnType CanTp_EncodeNAIValue(const CanTp_AddressingFormatType af,
                                           const CanTp_NAeType *pNAe,
                                           const CanTp_NTaType *pNTa,
                                           uint8 *pBuffer,
                                           PduLengthType *pOfs);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

/**
 * @brief this function decodes a raw minimum separation time (STmin) to a value in microsecond(s),
 * according to ISO 15765-2.
 *
 * @note see section 6.5.5.5 of ISO 15765-2.
 *
 * @param data [in]: the raw minimum separation time (8 bits STmin value)
 * @return decoded minimum separation time value [μs]
 */
static uint32_least CanTp_DecodeSTMinValue(const uint8 data);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

/**
 * @brief this function encodes a minimum separation time in microsecond(s) (STmin) to a 8 bits
 * value, according to ISO 15765-2.
 *
 * @note see section 6.5.5.5 of ISO 15765-2.
 *
 * @param value [in]: the minimum separation time [μs]
 * @return encoded minimum separation time value (8 bits STmin value)
 */
static uint8 CanTp_EncodeSTMinValue(uint16 value);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static Std_ReturnType CanTp_DecodePCIValue(CanTp_NPciType *pPci, const uint8 *pData);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static PduLengthType CanTp_DecodeDLValue(const CanTp_NPciType frameType,
                                         const CanTp_RxPaddingActivationType padding,
                                         const uint8 *pData);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static void CanTp_AbortTxSession(CanTp_NSduType *pNSdu, uint8 instanceId, boolean confirm);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static void CanTp_PerformStepRx(CanTp_NSduType *pNSdu);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static void CanTp_PerformStepTx(CanTp_NSduType *pNSdu);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static BufReq_ReturnType CanTp_CopyRxPayload(CanTp_NSduType *pNSdu);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static BufReq_ReturnType CanTp_CopyTxPayload(CanTp_NSduType *pNSdu, PduLengthType *pOfs);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static void CanTp_SetPadding(uint8 *pBuffer, PduLengthType *pOfs, const uint8 value);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static CanTp_FrameStateType CanTp_LDataReqTSF(CanTp_NSduType *pNSdu);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static CanTp_FrameStateType CanTp_LDataReqTFF(CanTp_NSduType *pNSdu);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static CanTp_FrameStateType CanTp_LDataReqTCF(CanTp_NSduType *pNSdu);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static CanTp_FrameStateType CanTp_LDataReqRFC(CanTp_NSduType *pNSdu);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static CanTp_FrameStateType
CanTp_LDataIndRSF(CanTp_NSduType *pNSdu, const PduInfoType *pPduInfo, const PduLengthType nAeSize);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static CanTp_FrameStateType
CanTp_LDataIndRFF(CanTp_NSduType *pNSdu, const PduInfoType *pPduInfo, const PduLengthType nAeSize);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static CanTp_FrameStateType
CanTp_LDataIndRCF(CanTp_NSduType *pNSdu, const PduInfoType *pPduInfo, const PduLengthType nAeSize);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static CanTp_FrameStateType
CanTp_LDataIndTFC(CanTp_NSduType *pNSdu, const PduInfoType *pPduInfo);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static CanTp_FrameStateType CanTp_LDataConRFC(CanTp_NSduType *pNSdu);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static CanTp_FrameStateType CanTp_LDataConTSF(CanTp_NSduType *pNSdu);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static CanTp_FrameStateType CanTp_LDataConTFF(CanTp_NSduType *pNSdu);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

#define CanTp_START_SEC_CODE_FAST
#include "CanTp_MemMap.h"

static CanTp_FrameStateType CanTp_LDataConTCF(CanTp_NSduType *pNSdu);

#define CanTp_STOP_SEC_CODE_FAST
#include "CanTp_MemMap.h"

/** @} */


/*-----------------------------------------------------------------------------------------------*/
/* local constant definitions (static const).                                                    */
/*-----------------------------------------------------------------------------------------------*/

/**
 * @addtogroup CANTP_C_LCDEF
 * @{
 */

#define CanTp_START_SEC_VAR_FAST_INIT_UNSPECIFIED
#include "CanTp_MemMap.h"

static const CanTp_ConfigType *CanTp_ConfigPtr = NULL_PTR;

#define CanTp_STOP_SEC_VAR_FAST_INIT_UNSPECIFIED
#include "CanTp_MemMap.h"

/** @} */


/*-----------------------------------------------------------------------------------------------*/
/* local variable definitions (static).                                                          */
/*-----------------------------------------------------------------------------------------------*/

/**
 * @addtogroup CANTP_C_LVDEF
 * @{
 */

#define CanTp_START_SEC_VAR_FAST_CLEARED_UNSPECIFIED
#include "CanTp_MemMap.h"

static CanTp_ChannelRtType CanTp_Rt[CANTP_MAX_NUM_OF_CHANNEL];

#define CanTp_STOP_SEC_VAR_FAST_CLEARED_UNSPECIFIED
#include "CanTp_MemMap.h"

/** @} */


/*-----------------------------------------------------------------------------------------------*/
/* global constant definitions (extern const).                                                   */
/*-----------------------------------------------------------------------------------------------*/

/**
 * @addtogroup CANTP_C_GCDEF
 * @{
 */

/** @} */


/*-----------------------------------------------------------------------------------------------*/
/* global variable definitions (extern).                                                         */
/*-----------------------------------------------------------------------------------------------*/

/**
 * @addtogroup CANTP_C_GVDEF
 * @{
 */

#define CanTp_START_SEC_VAR_FAST_POWER_ON_INIT_UNSPECIFIED
#include "CanTp_MemMap.h"

CanTp_StateType CanTp_State = CANTP_OFF;

#define CanTp_STOP_SEC_VAR_FAST_POWER_ON_INIT_UNSPECIFIED
#include "CanTp_MemMap.h"

/** @} */


/*-----------------------------------------------------------------------------------------------*/
/* global function definitions.                                                                  */
/*-----------------------------------------------------------------------------------------------*/

/**
 * @addtogroup CANTP_C_GFDEF
 * @{
 */

void CanTp_Init(const CanTp_ConfigType *pConfig)
{
    Std_ReturnType result = E_OK;
    uint32_least n_sdu_range;
    uint32_least channel_idx;
    uint32_least rt_sdu_idx;
    uint32_least cfg_sdu_idx;
    const CanTp_ChannelType *p_cfg_channel;
    CanTp_ChannelRtType *p_rt_channel;
    CanTp_NSduType *p_rt_sdu;
    const CanTp_RxNSduType *p_cfg_rx_sdu;
    const CanTp_TxNSduType *p_cfg_tx_sdu;

    if (pConfig != NULL_PTR)
    {
        CanTp_ConfigPtr = pConfig;

        uint8 *p_cleared_data = (uint8 *)&CanTp_Rt[0x00u];
        uint32_least idx;

        for (idx = 0x00u; idx < sizeof(CanTp_Rt); idx++)
        {
            p_cleared_data[idx] = 0x00u;
        }
        /* iterate over all statically defined channels. */
        for (channel_idx = 0x00u; channel_idx < pConfig->maxChannelCnt; channel_idx++)
        {
            p_rt_channel = &CanTp_Rt[channel_idx];
            p_cfg_channel = &pConfig->pChannel[channel_idx];

            /* make sure the static configuration's PDU count fits into provided
             * CANTP_MAX_NUM_OF_N_SDU. */
            n_sdu_range = p_cfg_channel->nSdu.rxNSduCnt + p_cfg_channel->nSdu.txNSduCnt;

            if (n_sdu_range <= (uint32_least)CANTP_MAX_NUM_OF_N_SDU)
            {
                for (rt_sdu_idx = 0x00u; rt_sdu_idx < (uint32_least)CANTP_MAX_NUM_OF_N_SDU; rt_sdu_idx++)
                {
                    for (cfg_sdu_idx = 0x00u;
                         cfg_sdu_idx < p_cfg_channel->nSdu.rxNSduCnt; cfg_sdu_idx++)
                    {
                        if (p_cfg_channel->nSdu.rx != NULL_PTR)
                        {
                            p_cfg_rx_sdu = &p_cfg_channel->nSdu.rx[cfg_sdu_idx];

                            /* make sure the nSduId is in allowed range. */
                            if (p_cfg_rx_sdu->nSduId < n_sdu_range)
                            {
                                if (p_cfg_rx_sdu->nSduId == rt_sdu_idx)
                                {
                                    p_rt_sdu = &p_rt_channel->sdu[p_cfg_rx_sdu->nSduId];

                                    p_rt_sdu->dir |= CANTP_DIRECTION_RX;
                                    p_rt_sdu->rx.cfg = p_cfg_rx_sdu;
                                    p_rt_sdu->rx.shared.taskState = CANTP_WAIT;
                                    p_rt_sdu->rx.shared.m_param.st_min = p_cfg_rx_sdu->sTMin;
                                    p_rt_sdu->rx.shared.m_param.bs = p_cfg_rx_sdu->bs;
                                }
                            }
                            else
                            {
                                result = E_NOT_OK;

                                break;
                            }
                        }
                    }

                    for (cfg_sdu_idx = 0x00u;
                         cfg_sdu_idx < p_cfg_channel->nSdu.txNSduCnt; cfg_sdu_idx++)
                    {
                        if (p_cfg_channel->nSdu.tx != NULL_PTR)
                        {
                            p_cfg_tx_sdu = &p_cfg_channel->nSdu.tx[cfg_sdu_idx];

                            /* make sure the nSduId is in allowed range. */
                            if (p_cfg_tx_sdu->nSduId < n_sdu_range)
                            {
                                if (p_cfg_tx_sdu->nSduId == rt_sdu_idx)
                                {
                                    p_rt_sdu = &p_rt_channel->sdu[p_cfg_tx_sdu->nSduId];

                                    p_rt_sdu->dir |= CANTP_DIRECTION_TX;
                                    p_rt_sdu->tx.cfg = p_cfg_tx_sdu;
                                    p_rt_sdu->tx.taskState = CANTP_WAIT;
                                }
                            }
                            else
                            {
                                result = E_NOT_OK;

                                break;
                            }
                        }
                    }
                }
            }
            else
            {
                result = E_NOT_OK;

                break;
            }
        }

        if (result != E_OK)
        {
            CanTp_ReportError(0x00u, CANTP_INIT_API_ID, CANTP_E_INIT_FAILED);
        }
        else
        {
            CanTp_State = CANTP_ON;
        }
    }
    else
    {
        CanTp_ReportError(0x00u, CANTP_INIT_API_ID, CANTP_E_PARAM_POINTER);
    }
}

#if (CANTP_GET_VERSION_INFO_API == STD_ON)

void CanTp_GetVersionInfo(Std_VersionInfoType *pVersionInfo)
{
    if (pVersionInfo != NULL_PTR)
    {
        pVersionInfo->vendorID = 0x00u;
        pVersionInfo->moduleID = (uint16)CANTP_MODULE_ID;
        pVersionInfo->sw_major_version = CANTP_SW_MAJOR_VERSION;
        pVersionInfo->sw_minor_version = CANTP_SW_MINOR_VERSION;
        pVersionInfo->sw_patch_version = CANTP_SW_PATCH_VERSION;
    }
    else
    {
        CanTp_ReportError(0x00u, CANTP_GET_VERSION_INFO_API_ID, CANTP_E_PARAM_POINTER);
    }
}

#endif /* #if (CANTP_GET_VERSION_INFO_API == STD_ON) */

void CanTp_Shutdown(void)
{
    if ((CanTp_StateType)CanTp_State != (CanTp_StateType)CANTP_OFF)
    {
        CanTp_State = CANTP_OFF;
    }
    else
    {
        CanTp_ReportError(0x00u, CANTP_SHUTDOWN_API_ID, CANTP_E_UNINIT);
    }

}

Std_ReturnType CanTp_Transmit(PduIdType txPduId, const PduInfoType *pPduInfo)
{
    CanTp_NSduType *p_n_sdu = NULL_PTR;
    Std_ReturnType tmp_return = E_NOT_OK;

    if ((CanTp_StateType)CanTp_State == (CanTp_StateType)CANTP_ON)
    {
        if (pPduInfo != NULL_PTR)
        {
            if (CanTp_GetNSduFromPduId(txPduId, &p_n_sdu) == E_OK)
            {
                /* SWS_CanTp_00206: the function CanTp_Transmit shall reject a request if the CanTp_Transmit
                 * service is called for a N-SDU identifier which is being used in a currently running CAN
                 * Transport Layer session. */
                if ((p_n_sdu->tx.taskState != CANTP_PROCESSING) &&
                    (pPduInfo->SduLength > 0x0000u) &&
                    (pPduInfo->SduLength <= 0x0FFFu))
                {
                    p_n_sdu->tx.buf.size = pPduInfo->SduLength;

                    if ((((p_n_sdu->tx.cfg->af == CANTP_STANDARD) ||
                          (p_n_sdu->tx.cfg->af == CANTP_NORMALFIXED)) &&
                         (pPduInfo->SduLength <= 0x07u)) ||
                        (((p_n_sdu->tx.cfg->af == CANTP_EXTENDED) ||
                          (p_n_sdu->tx.cfg->af == CANTP_MIXED) ||
                          (p_n_sdu->tx.cfg->af == CANTP_MIXED29BIT)) &&
                         (pPduInfo->SduLength <= 0x06u)))
                    {
                        p_n_sdu->tx.shared.state = CANTP_TX_FRAME_STATE_SF_TX_REQUEST;
                        tmp_return = E_OK;
                    }
                    else
                    {
                        if (p_n_sdu->tx.cfg->taType == CANTP_PHYSICAL)
                        {
                            p_n_sdu->tx.shared.state = CANTP_TX_FRAME_STATE_FF_TX_REQUEST;
                            tmp_return = E_OK;
                        }
                        else
                        {
                            /* SWS_CanTp_00093: If a multiple segmented session occurs (on both receiver and
                             * sender  side) with a handle whose communication type is functional, the CanTp
                             * module shall reject the request and report the runtime error code
                             * CANTP_E_INVALID_TATYPE to the Default Error Tracer. */
                            CanTp_ReportRuntimeError(0x00u, CANTP_TRANSMIT_API_ID,
                                                     CANTP_E_INVALID_TATYPE);
                        }
                    }

                    if (tmp_return == E_OK)
                    {
                        p_n_sdu->tx.taskState = CANTP_PROCESSING;
                    }
                }
            }
            else
            {
                CanTp_ReportError(0x00u, CANTP_TRANSMIT_API_ID, CANTP_E_INVALID_TX_ID);
            }
        }
        else
        {
            CanTp_ReportError(0x00u, CANTP_TRANSMIT_API_ID, CANTP_E_PARAM_POINTER);
        }
    }
    else
    {
        CanTp_ReportError(0x00u, CANTP_TRANSMIT_API_ID, CANTP_E_UNINIT);
    }

    return tmp_return;
}

Std_ReturnType CanTp_CancelTransmit(PduIdType txPduId)
{
    CanTp_NSduType *p_n_sdu;
    Std_ReturnType tmp_return = E_NOT_OK;

    if ((CanTp_StateType)CanTp_State == (CanTp_StateType)CANTP_ON)
    {
        if ((CanTp_GetNSduFromPduId(txPduId, &p_n_sdu) == E_OK) &&
            ((p_n_sdu->dir & CANTP_DIRECTION_TX) != 0x00u))
        {
            if (p_n_sdu->tx.taskState == CANTP_PROCESSING)
            {
                p_n_sdu->tx.taskState = CANTP_WAIT;

                /* SWS_CanTp_00255: If the CanTp_CancelTransmit service has been successfully executed
                 * the CanTp shall call the PduR_CanTpTxConfirmation with notification result E_NOT_OK.
                 */
                PduR_CanTpTxConfirmation(p_n_sdu->tx.cfg->nSduId, E_NOT_OK);

                tmp_return = E_OK;
            }
            else
            {
                /* SWS_CanTp_00254: if development error detection is enabled the function
                 * CanTp_CancelTransmit shall check the validity of TxPduId parameter. If the parameter
                 * value is invalid, the CanTp_CancelTransmit function shall raise the development error
                 * CANTP_E_PARAM_ID and return E_NOT_OK (see SWS_CanTp_00294).
                 * if the parameter value indicates a cancel transmission request for an N-SDU that it
                 * is not on transmission process the CanTp module shall report a runtime error code
                 * CANTP_E_OPER_NOT_SUPPORTED to the Default Error Tracer and the service shall return
                 * E_NOT_OK. */
                CanTp_ReportRuntimeError(0x00u, CANTP_CANCEL_TRANSMIT_API_ID, CANTP_E_OPER_NOT_SUPPORTED);
            }
        }
        else
        {
            CanTp_ReportError(0x00u, CANTP_CANCEL_TRANSMIT_API_ID, CANTP_E_PARAM_ID);
        }
    }
    else
    {
        CanTp_ReportError(0x00u, CANTP_CANCEL_TRANSMIT_API_ID, CANTP_E_UNINIT);
    }

    return tmp_return;
}

Std_ReturnType CanTp_CancelReceive(PduIdType rxPduId)
{
    CanTp_NSduType *p_n_sdu;
    CanTp_TaskStateType task_state;
    PduLengthType n_ae_field_size;
    Std_ReturnType tmp_return = E_NOT_OK;

    if ((CanTp_StateType)CanTp_State == (CanTp_StateType)CANTP_ON)
    {
        if ((CanTp_GetNSduFromPduId(rxPduId, &p_n_sdu) == E_OK) &&
            ((p_n_sdu->dir & CANTP_DIRECTION_RX) != 0x00u))
        {
            (void)CanTp_DecodeNAIValue(p_n_sdu->rx.cfg->af, &n_ae_field_size);
            CANTP_ENTER_CRITICAL_SECTION
            task_state = p_n_sdu->rx.shared.taskState;
            CANTP_EXIT_CRITICAL_SECTION

            if (task_state == CANTP_PROCESSING)
            {
                /* SWS_CanTp_00262: The CanTp shall reject the request for receive cancellation in case
                 * of a Single Frame reception or if the CanTp is in the process of receiving the last
                 * Consecutive Frame of the N-SDU (i.e. the service is called after N-Cr timeout is
                 * started for the last Consecutive Frame). In this case the CanTp shall return
                 * E_NOT_OK. */
                if (p_n_sdu->rx.buf.size > ((CANTP_CAN_FRAME_SIZE - CANTP_CF_PCI_FIELD_SIZE) + n_ae_field_size))
                {
                    CANTP_ENTER_CRITICAL_SECTION
                    p_n_sdu->rx.shared.taskState = CANTP_WAIT;
                    CANTP_EXIT_CRITICAL_SECTION

                    /* SWS_CanTp_00263: if the CanTp_CancelReceive service has been successfully
                     * executed the CanTp shall call the PduR_CanTpRxIndication with notification
                     * result E_NOT_OK. */
                    PduR_CanTpRxIndication(p_n_sdu->rx.cfg->nSduId, E_NOT_OK);

                    tmp_return = E_OK;
                }
            }
            else
            {
                /* SWS_CanTp_00260: If the parameter value indicates a cancel reception request for an
                 * N-SDU that it is not on reception process the CanTp module shall report the runtime
                 * error code CANTP_E_OPER_NOT_SUPPORTED to the Default Error Tracer and the service
                 * shall return E_NOT_OK. */
                CanTp_ReportRuntimeError(0x00u, CANTP_CANCEL_RECEIVE_API_ID, CANTP_E_OPER_NOT_SUPPORTED);
            }
        }
        else
        {
            /* SWS_CanTp_00260: if development error detection is enabled the function
             * CanTp_CancelReceive shall check the validity of RxPduId parameter. if the parameter value
             * is invalid, the CanTp_CancelReceive function shall raise the development error
             * CANTP_E_PARAM_ID and return E_NOT_OK (see SWS_CanTp_00294). */
            CanTp_ReportError(0x00u, CANTP_CANCEL_RECEIVE_API_ID, CANTP_E_PARAM_ID);
        }
    }
    else
    {
        CanTp_ReportError(0x00u, CANTP_CANCEL_RECEIVE_API_ID, CANTP_E_UNINIT);
    }

    return tmp_return;
}

#if (CANTP_CHANGE_PARAMETER_API == STD_ON)

Std_ReturnType CanTp_ChangeParameter(PduIdType pduId, TPParameterType parameter, uint16 value)
{
    CanTp_NSduType *p_n_sdu;
    CanTp_TaskStateType task_state;
    Std_ReturnType tmp_return = E_NOT_OK;

    if ((CanTp_StateType)CanTp_State == (CanTp_StateType)CANTP_ON)
    {

        if (CanTp_GetNSduFromPduId(pduId, &p_n_sdu) == E_OK)
        {
            CANTP_ENTER_CRITICAL_SECTION
            task_state = p_n_sdu->rx.shared.taskState;
            CANTP_EXIT_CRITICAL_SECTION

            if (task_state != CANTP_PROCESSING)
            {
                switch (parameter)
                {
                    case TP_STMIN:
                    {
                        if ((value <= 0xFFu) && ((p_n_sdu->dir & CANTP_DIRECTION_RX) != 0x00u))
                        {
                            CANTP_ENTER_CRITICAL_SECTION
                            p_n_sdu->rx.shared.m_param.st_min = value;
                            CANTP_EXIT_CRITICAL_SECTION

                            tmp_return = E_OK;
                        }

                        break;
                    }
                    case TP_BS:
                    {
                        if ((value <= 0xFFu) && ((p_n_sdu->dir & CANTP_DIRECTION_RX) != 0x00u))
                        {
                            CANTP_ENTER_CRITICAL_SECTION
                            p_n_sdu->rx.shared.m_param.bs = (uint8)value;
                            CANTP_EXIT_CRITICAL_SECTION

                            tmp_return = E_OK;
                        }

                        break;
                    }
                    case TP_BC:
                    default:
                    {
                        break;
                    }
                }

                if (tmp_return != E_OK)
                {
                    CanTp_ReportError(0x00u, CANTP_CHANGE_PARAMETER_API_ID, CANTP_E_PARAM_ID);
                }
            }
        }
        else
        {
            CanTp_ReportError(0x00u, CANTP_CHANGE_PARAMETER_API_ID, CANTP_E_PARAM_ID);
        }

    }
    else
    {
        CanTp_ReportError(0x00u, CANTP_CHANGE_PARAMETER_API_ID, CANTP_E_UNINIT);
    }

    return tmp_return;
}

#endif /* #if (CANTP_CHANGE_PARAMETER_API == STD_ON) */

#if (CANTP_READ_PARAMETER_API == STD_ON)

Std_ReturnType CanTp_ReadParameter(PduIdType pduId, TPParameterType parameter, uint16 *pValue)
{
    CanTp_NSduType *p_n_sdu;
    uint16 value;
    Std_ReturnType tmp_return = E_NOT_OK;

    if ((CanTp_StateType)CanTp_State == (CanTp_StateType)CANTP_ON)
    {
        if (pValue != NULL_PTR)
        {
            if (CanTp_GetNSduFromPduId(pduId, &p_n_sdu) == E_OK)
            {
                if ((p_n_sdu->dir & CANTP_DIRECTION_RX) != 0x00u)
                {
                    switch (parameter)
                    {
                        case TP_STMIN:
                        {
                            CANTP_ENTER_CRITICAL_SECTION
                            value = (uint16)p_n_sdu->rx.shared.m_param.st_min;
                            CANTP_EXIT_CRITICAL_SECTION

                            *pValue = value;
                            tmp_return = E_OK;

                            break;
                        }
                        case TP_BS:
                        {
                            CANTP_ENTER_CRITICAL_SECTION
                            value = (uint16)p_n_sdu->rx.shared.m_param.bs;
                            CANTP_EXIT_CRITICAL_SECTION

                            *pValue = value;
                            tmp_return = E_OK;

                            break;
                        }
                        case TP_BC:
                        default:
                        {
                            CanTp_ReportError(0x00u, CANTP_READ_PARAMETER_API_ID, CANTP_E_PARAM_ID);

                            break;
                        }
                    }
                }
            }
            else
            {
                CanTp_ReportError(0x00u, CANTP_READ_PARAMETER_API_ID, CANTP_E_PARAM_ID);
            }
        }
        else
        {
            CanTp_ReportError(0x00u, CANTP_READ_PARAMETER_API_ID, CANTP_E_PARAM_POINTER);
        }
    }
    else
    {
        CanTp_ReportError(0x00u, CANTP_READ_PARAMETER_API_ID, CANTP_E_UNINIT);
    }

    return tmp_return;
}

#endif /* #if (CANTP_READ_PARAMETER_API == STD_ON) */

/** @} */


/*-----------------------------------------------------------------------------------------------*/
/* global scheduled function definitions.                                                        */
/*-----------------------------------------------------------------------------------------------*/

/**
 * @addtogroup CANTP_C_GSFDEF
 * @{
 */

void CanTp_MainFunction(void)
{
    uint32_least channel_idx;
    uint32_least n_sdu_idx;
    CanTp_NSduType *p_n_sdu;

    CanTp_TaskStateType task_state_rx;
    CanTp_TaskStateType task_state_tx;

    if ((CanTp_StateType)CanTp_State == (CanTp_StateType)CANTP_ON)
    {
        for (channel_idx = 0x00u; channel_idx < (uint32_least)CANTP_MAX_NUM_OF_CHANNEL; channel_idx++)
        {
            for (n_sdu_idx = 0x00u; n_sdu_idx < (uint32_least)CANTP_MAX_NUM_OF_N_SDU; n_sdu_idx++)
            {
                p_n_sdu = &CanTp_Rt[channel_idx].sdu[n_sdu_idx];

                CANTP_ENTER_CRITICAL_SECTION
                task_state_rx = p_n_sdu->rx.shared.taskState;
                CANTP_EXIT_CRITICAL_SECTION

                task_state_tx = p_n_sdu->tx.taskState;

                if (task_state_rx == CANTP_PROCESSING)
                {
                    CanTp_PerformStepRx(p_n_sdu);
                }

                if (task_state_tx == CANTP_PROCESSING)
                {
                    CanTp_PerformStepTx(p_n_sdu);
                }

                CANTP_ENTER_CRITICAL_SECTION
                p_n_sdu->n[0x00u] += CanTp_ConfigPtr->mainFunctionPeriod;
                p_n_sdu->n[0x01u] += CanTp_ConfigPtr->mainFunctionPeriod;
                p_n_sdu->n[0x02u] += CanTp_ConfigPtr->mainFunctionPeriod;
                p_n_sdu->n[0x03u] += CanTp_ConfigPtr->mainFunctionPeriod;
                p_n_sdu->n[0x04u] += CanTp_ConfigPtr->mainFunctionPeriod;
                p_n_sdu->n[0x05u] += CanTp_ConfigPtr->mainFunctionPeriod;
                p_n_sdu->rx.st_min += CanTp_ConfigPtr->mainFunctionPeriod;
                p_n_sdu->tx.st_min += CanTp_ConfigPtr->mainFunctionPeriod;
                CANTP_EXIT_CRITICAL_SECTION
            }
        }
    }
    else
    {
        CanTp_ReportError(0x00u, CANTP_MAIN_FUNCTION_API_ID, CANTP_E_UNINIT);
    }
}

/** @} */


/*-----------------------------------------------------------------------------------------------*/
/* global callback function definitions.                                                         */
/*-----------------------------------------------------------------------------------------------*/

/**
 * @addtogroup CANTP_C_GCFDEF
 * @{
 */

static void CanTp_StartNetworkLayerTimeout(CanTp_NSduType *pNSdu, const uint8 instanceId)
{
    if ((pNSdu->t_flag & ((uint32)0x01u << instanceId)) == 0x00u)
    {
        pNSdu->t_flag |= ((uint32)0x01u << instanceId);
        pNSdu->n[instanceId] = 0x00u;
    }
}

static void CanTp_StopNetworkLayerTimeout(CanTp_NSduType *pNSdu, const uint8 instanceId)
{
    pNSdu->t_flag &= ~((uint32)0x01u << instanceId);
}

static boolean CanTp_NetworkLayerTimeoutExpired(const CanTp_NSduType *pNSdu, const uint8 instanceId)
{
    boolean result = FALSE;

    switch (instanceId)
    {
        case CANTP_I_N_AS:
        {
            if ((pNSdu->n[CANTP_I_N_AS] >= pNSdu->tx.cfg->nas) &&
                ((pNSdu->t_flag & ((uint32)0x01u /* << CANTP_I_N_AS */)) != 0x00u))
            {
                result = TRUE;
            }

            break;
        }
        case CANTP_I_N_BS:
        {
            if ((pNSdu->n[CANTP_I_N_BS] >= pNSdu->tx.cfg->nbs) &&
                ((pNSdu->t_flag & ((uint32)0x01u << CANTP_I_N_BS)) != 0x00u))
            {
                result = TRUE;
            }

            break;
        }
        case CANTP_I_N_CS:
        {
            if ((pNSdu->n[CANTP_I_N_CS] >= pNSdu->tx.cfg->ncs) &&
                ((pNSdu->t_flag & ((uint32)0x01u << CANTP_I_N_CS)) != 0x00u))
            {
                result = TRUE;
            }

            break;
        }
        case CANTP_I_N_AR:
        {
            if ((pNSdu->n[CANTP_I_N_AR] >= pNSdu->rx.cfg->nar) &&
                ((pNSdu->t_flag & ((uint32)0x01u << CANTP_I_N_AR)) != 0x00u))
            {
                result = TRUE;
            }

            break;
        }
        case CANTP_I_N_BR:
        {
            if ((pNSdu->n[CANTP_I_N_BR] >= pNSdu->rx.cfg->nbr) &&
                ((pNSdu->t_flag & ((uint32)0x01u << CANTP_I_N_BR)) != 0x00u))
            {
                result = TRUE;
            }

            break;
        }
        case CANTP_I_N_CR:
        {
            if ((pNSdu->n[CANTP_I_N_CR] >= pNSdu->rx.cfg->ncr) &&
                ((pNSdu->t_flag & ((uint32)0x01u << CANTP_I_N_CR)) != 0x00u))
            {
                result = TRUE;
            }

            break;
        }
        default:
        {
            break;
        }
    }

    return result;
}

static boolean CanTp_NetworkLayerIsActive(const CanTp_NSduType *pNSdu, const uint8 instanceId)
{
    boolean result;

    if ((pNSdu->t_flag & ((uint32)0x01u << instanceId)) == 0x00u)
    {
        result = FALSE;
    }
    else
    {
        result = TRUE;
    }

    return result;
}

static void CanTp_StartFlowControlTimeout(CanTp_NSduType *pNSdu)
{
    if ((pNSdu->tx.shared.flag & CANTP_I_ST_MIN) == 0x00u)
    {
        pNSdu->tx.shared.flag |= CANTP_I_ST_MIN;
        pNSdu->tx.st_min = 0x00u;
    }
}

static boolean CanTp_FlowControlActive(const CanTp_NSduType *pNSdu)
{
    boolean result = FALSE;

    if ((pNSdu->tx.shared.flag & CANTP_I_ST_MIN) != 0x00u)
    {
        result = TRUE;
    }

    return result;
}

static boolean CanTp_FlowControlExpired(CanTp_NSduType *pNSdu)
{
    boolean result = FALSE;

    if ((pNSdu->tx.st_min >= pNSdu->tx.target_st_min) &&
        ((pNSdu->tx.shared.flag & CANTP_I_ST_MIN) != 0x00u))
    {
        result = TRUE;
        pNSdu->tx.shared.flag &= ~(CANTP_I_ST_MIN);
    }

    return result;
}

static CanTp_FrameStateType CanTp_LDataReqTSF(CanTp_NSduType *pNSdu)
{
    CanTp_FrameStateType tmp_return = CANTP_TX_FRAME_STATE_SF_TX_REQUEST;
    CanTp_NSduType *p_n_sdu = pNSdu;
    PduInfoType *p_pdu_info = &p_n_sdu->tx.can_if_pdu_info;
    PduLengthType ofs = 0x00u;

    p_pdu_info->SduDataPtr = &p_n_sdu->tx.buf.can[0x00u];

    if (CanTp_EncodeNAIValue(p_n_sdu->tx.cfg->af,
                             p_n_sdu->tx.cfg->pNAe,
                             p_n_sdu->tx.cfg->pNTa,
                             &p_pdu_info->SduDataPtr[ofs],
                             &ofs) == E_OK)
    {
        /* prevent lint issue by providing zero valued rhs argument to operators '<<' and '|'. */
        p_pdu_info->SduDataPtr[ofs] = /* (uint8)((uint8)CANTP_N_PCI_TYPE_SF << 0x04u) | */
            (uint8)pNSdu->tx.buf.size;
        ofs = ofs + 0x01u;

        if (CanTp_CopyTxPayload(p_n_sdu, &ofs) == BUFREQ_OK)
        {
            tmp_return = CANTP_TX_FRAME_STATE_SF_TX_CONFIRMATION;

            /* SWS_CanTp_00348: if frames with a payload <= 8 (either CAN 2.0 frames or small CAN FD
             * frames) are used for a Tx N-SDU and if CanTpTxPaddingActivation is equal to CANTP_ON,
             * CanTp shall transmit by means of CanIf_Transmit() call, SF Tx N-PDU or last CF Tx
             * N-PDU that belongs to that Tx N-SDU with the length of eight bytes(i.e.
             * PduInfoPtr.SduLength = 8). Unused bytes in N-PDU shall be updated with
             * CANTP_PADDING_BYTE (see ECUC_CanTp_00298). */
            if (p_n_sdu->tx.cfg->padding == CANTP_ON)
            {
                CanTp_SetPadding(&p_pdu_info->SduDataPtr[0x00u], &ofs, CanTp_ConfigPtr->paddingByte);
            }

            p_pdu_info->SduLength = ofs;
        }
    }

    return tmp_return;
}

static CanTp_FrameStateType CanTp_LDataReqTFF(CanTp_NSduType *pNSdu)
{
    CanTp_FrameStateType tmp_return = CANTP_TX_FRAME_STATE_FF_TX_REQUEST;
    CanTp_NSduType *p_n_sdu = pNSdu;
    PduInfoType *p_pdu_info = &p_n_sdu->tx.can_if_pdu_info;
    PduLengthType ofs = 0x00u;

    p_pdu_info->SduDataPtr = &p_n_sdu->tx.buf.can[0x00u];

    if (CanTp_EncodeNAIValue(p_n_sdu->tx.cfg->af,
                             p_n_sdu->tx.cfg->pNAe,
                             p_n_sdu->tx.cfg->pNTa,
                             &p_pdu_info->SduDataPtr[ofs],
                             &ofs) == E_OK)
    {
        p_n_sdu->tx.sn = 0x00u;

        p_pdu_info->SduDataPtr[ofs] = (uint8)(CANTP_N_PCI_TYPE_FF << 0x04u) |
            (uint8)((uint8)(pNSdu->tx.buf.size  >> (uint8)0x08u) & (uint8)0x0Fu);
        ofs ++;
        p_pdu_info->SduDataPtr[ofs] = (uint8)pNSdu->tx.buf.size & 0xFFu;
        ofs ++;

        if (CanTp_CopyTxPayload(p_n_sdu, &ofs) == BUFREQ_OK)
        {
            tmp_return = CANTP_TX_FRAME_STATE_FF_TX_CONFIRMATION;

            /* SWS_CanTp_00348: if frames with a payload <= 8 (either CAN 2.0 frames or small CAN FD
             * frames) are used for a Tx N-SDU and if CanTpTxPaddingActivation is equal to CANTP_ON,
             * CanTp shall transmit by means of CanIf_Transmit() call, SF Tx N-PDU or last CF Tx
             * N-PDU that belongs to that Tx N-SDU with the length of eight bytes(i.e.
             * PduInfoPtr.SduLength = 8). Unused bytes in N-PDU shall be updated with
             * CANTP_PADDING_BYTE (see ECUC_CanTp_00298). */
            if (p_n_sdu->tx.cfg->padding == CANTP_ON)
            {
                CanTp_SetPadding(&p_pdu_info->SduDataPtr[0x00u], &ofs, CanTp_ConfigPtr->paddingByte);
            }

            p_pdu_info->SduLength = ofs;
        }
    }

    return tmp_return;
}

static CanTp_FrameStateType CanTp_LDataReqTCF(CanTp_NSduType *pNSdu)
{
    CanTp_FrameStateType tmp_return = CANTP_TX_FRAME_STATE_CF_TX_REQUEST;
    CanTp_NSduType *p_n_sdu = pNSdu;
    PduInfoType *p_pdu_info = &p_n_sdu->tx.can_if_pdu_info;
    PduLengthType ofs = 0x00u;

    p_pdu_info->SduDataPtr = &p_n_sdu->tx.buf.can[0x00u];

    if (CanTp_EncodeNAIValue(p_n_sdu->tx.cfg->af,
                             p_n_sdu->tx.cfg->pNAe,
                             p_n_sdu->tx.cfg->pNTa,
                             &p_pdu_info->SduDataPtr[ofs],
                             &ofs) == E_OK)
    {
        p_pdu_info->SduDataPtr[ofs] = (uint8)((uint8)CANTP_N_PCI_TYPE_CF << 0x04u) | (p_n_sdu->tx.sn & 0x0Fu);
        ofs ++;

        if (CanTp_CopyTxPayload(p_n_sdu, &ofs) == BUFREQ_OK)
        {
            tmp_return = CANTP_TX_FRAME_STATE_CF_TX_CONFIRMATION;

            p_n_sdu->tx.sn ++;

            /* SWS_CanTp_00348: if frames with a payload <= 8 (either CAN 2.0 frames or small CAN FD
             * frames) are used for a Tx N-SDU and if CanTpTxPaddingActivation is equal to CANTP_ON,
             * CanTp shall transmit by means of CanIf_Transmit() call, SF Tx N-PDU or last CF Tx
             * N-PDU that belongs to that Tx N-SDU with the length of eight bytes(i.e.
             * PduInfoPtr.SduLength = 8). Unused bytes in N-PDU shall be updated with
             * CANTP_PADDING_BYTE (see ECUC_CanTp_00298). */
            if (p_n_sdu->tx.cfg->padding == CANTP_ON)
            {
                CanTp_SetPadding(&p_pdu_info->SduDataPtr[0x00u], &ofs, CanTp_ConfigPtr->paddingByte);
            }

            p_pdu_info->SduLength = ofs;
        }
    }

    return tmp_return;
}

static CanTp_FrameStateType CanTp_LDataReqRFC(CanTp_NSduType *pNSdu)
{
    CanTp_FrameStateType tmp_return = CANTP_RX_FRAME_STATE_FC_TX_REQUEST;
    CanTp_NSduType *p_n_sdu = pNSdu;
    PduInfoType *p_pdu_info = &p_n_sdu->rx.can_if_pdu_info;
    uint16_least ofs = 0x00u;


    if (CanTp_EncodeNAIValue(p_n_sdu->rx.cfg->af,
                             p_n_sdu->rx.cfg->pNAe,
                             p_n_sdu->rx.cfg->pNTa,
                             &p_n_sdu->rx.buf.can[ofs],
                             &ofs) == E_OK)
    {
        if (p_n_sdu->rx.fs == CANTP_FLOW_STATUS_TYPE_WT)
        {
            if (CanTp_NetworkLayerTimeoutExpired(p_n_sdu, CANTP_I_N_BR) == TRUE)
            {
                if (p_n_sdu->rx.wft_max != 0x00u)
                {
                    p_n_sdu->rx.wft_max--;

                    CanTp_StopNetworkLayerTimeout(p_n_sdu, CANTP_I_N_BR);

                    if (p_n_sdu->rx.buf.rmng < CanTp_GetRxBlockSize(p_n_sdu))
                    {
                        /* SWS_CanTp_00341: If the N_Br timer expires and the available buffer size
                         * is still not big enough, the CanTp module shall send a new FC(WAIT) to
                         * suspend the N-SDU reception and reload the N_Br timer. */
                        CanTp_StartNetworkLayerTimeout(p_n_sdu, CANTP_I_N_BR);
                    }

                    tmp_return = CANTP_RX_FRAME_STATE_FC_TX_CONFIRMATION;
                }
                else
                {
                    /* SWS_CanTp_00223: The CanTp module shall send a maximum of WFTmax consecutive
                     * FC(WAIT) N-PDU. If this number is reached, the CanTp module shall abort the
                     * reception of this N-SDU (the receiver did not send any FC N-PDU, so the N_Bs
                     * timer expires on the sender side and then the transmission is aborted) and a
                     * receiving indication with E_NOT_OK occurs. */
                    tmp_return = CANTP_FRAME_STATE_ABORT;
                }
            }
            else
            {
                if (p_n_sdu->rx.buf.rmng >= CanTp_GetRxBlockSize(p_n_sdu))
                {
                    CanTp_StopNetworkLayerTimeout(p_n_sdu, CANTP_I_N_BR);
                    p_n_sdu->rx.fs = CANTP_FLOW_STATUS_TYPE_CTS;

                    tmp_return = CANTP_RX_FRAME_STATE_FC_TX_CONFIRMATION;
                }
            }
        }
        else if (p_n_sdu->rx.fs == CANTP_FLOW_STATUS_TYPE_OVFLW)
        {
            tmp_return = CANTP_RX_FRAME_STATE_FC_OVFLW_TX_CONFIRMATION;
        }
        else
        {
            tmp_return = CANTP_RX_FRAME_STATE_FC_TX_CONFIRMATION;
        }

        p_n_sdu->rx.buf.can[ofs] = (0x03u << 0x04u) | (uint8)p_n_sdu->rx.fs;
        ofs ++;
        p_n_sdu->rx.buf.can[ofs] = p_n_sdu->rx.cfg->bs;
        ofs ++;
        p_n_sdu->rx.buf.can[ofs] = CanTp_EncodeSTMinValue(p_n_sdu->rx.shared.m_param.st_min);
        ofs ++;

        /* SWS_CanTp_00348: if frames with a payload <= 8 (either CAN 2.0 frames or small CAN FD
         * frames) are used for a Tx N-SDU and if CanTpTxPaddingActivation is equal to CANTP_ON,
         * CanTp shall transmit by means of CanIf_Transmit() call, SF Tx N-PDU or last CF Tx N-PDU
         * that belongs to that Tx N-SDU with the length of eight bytes(i.e. PduInfoPtr.SduLength =
         * 8). Unused bytes in N-PDU shall be updated with CANTP_PADDING_BYTE (see
         * ECUC_CanTp_00298). */
        if ((CanTp_StateType)p_n_sdu->rx.cfg->padding == (CanTp_StateType)CANTP_ON)
        {
            CanTp_SetPadding(&p_n_sdu->rx.buf.can[0x00u], &ofs, CanTp_ConfigPtr->paddingByte);
        }

        p_pdu_info->SduDataPtr = &p_n_sdu->rx.buf.can[0x00u];
        p_pdu_info->MetaDataPtr = NULL_PTR;
        p_pdu_info->SduLength = ofs;
    }

    return tmp_return;
}

static CanTp_FrameStateType
CanTp_LDataIndRSF(CanTp_NSduType *pNSdu, const PduInfoType *pPduInfo, const PduLengthType nAeSize)
{
    PduLengthType dl;
    PduLengthType header_size;
    CanTp_FrameStateType result = CANTP_FRAME_STATE_INVALID;
    CanTp_NSduType *p_n_sdu = pNSdu;

    if (p_n_sdu->rx.shared.taskState == CANTP_PROCESSING)
    {
        /* SWS_CanTp_00057: Terminate the current reception, report an indication, with parameter
         * Result set to E_NOT_OK, to the upper layer, and process the SF/FF N-PDU as the start of a
         * new reception */
        PduR_CanTpRxIndication(p_n_sdu->rx.cfg->nSduId, E_NOT_OK);

        CanTp_ReportRuntimeError(CANTP_I_RX_SF, CANTP_RX_INDICATION_API_ID, CANTP_E_UNEXP_PDU);
    }
    else
    {
        CANTP_ENTER_CRITICAL_SECTION
        p_n_sdu->rx.shared.taskState = CANTP_PROCESSING;
        CANTP_EXIT_CRITICAL_SECTION
    }

    /* SWS_CanTp_00345: If frames with a payload <= 8 (either CAN 2.0 frames or small CAN FD frames)
     * are used for a Rx N-SDU and CanTpRxPaddingActivation is equal to CANTP_ON, then CanTp
     * receives by means of CanTp_RxIndication() call an SF Rx N-PDU belonging to that N-SDU, with a
     * length smaller than eight bytes (i.e. PduInfoPtr.SduLength < 8), CanTp shall reject the
     * reception. The runtime error code CANTP_E_PADDING shall be reported to the Default Error
     * Tracer. */
    header_size = CANTP_SF_PCI_FIELD_SIZE + nAeSize;

    dl = CanTp_DecodeDLValue(CANTP_N_PCI_TYPE_SF,
                             p_n_sdu->rx.cfg->padding,
                             &pPduInfo->SduDataPtr[nAeSize]);

    p_n_sdu->rx.buf.size = dl;

    p_n_sdu->rx.pdu_r_pdu_info.SduDataPtr = &pPduInfo->SduDataPtr[header_size];
    p_n_sdu->rx.pdu_r_pdu_info.SduLength = dl;
    p_n_sdu->rx.pdu_r_pdu_info.MetaDataPtr = NULL_PTR;

    switch (PduR_CanTpStartOfReception(p_n_sdu->rx.cfg->nSduId,
                                       &p_n_sdu->rx.pdu_r_pdu_info,
                                       dl,
                                       &p_n_sdu->rx.buf.rmng))
    {
        case BUFREQ_OK:
        {
            /* SWS_CanTp_00339: After the reception of a First Frame or Single Frame, if the
             * function PduR_CanTpStartOfReception() returns BUFREQ_OK with a smaller available
             * buffer size than needed for the already received data, the CanTp module shall
             * abort the reception of the N-SDU and call PduR_CanTpRxIndication() with the
             * result E_NOT_OK. */
            if (p_n_sdu->rx.buf.rmng < dl)
            {
                PduR_CanTpRxIndication(p_n_sdu->rx.cfg->nSduId, E_NOT_OK);

                /* TODO:return STATE_OK? */
                result = CANTP_FRAME_STATE_ABORT;
            }
            else
            {
                /* TODO: check the behavior to adopt if CanTp_CopyRxPayload does not return
                 *  BUFREQ_OK */
                (void)CanTp_CopyRxPayload(p_n_sdu);

                PduR_CanTpRxIndication(p_n_sdu->rx.cfg->nSduId, E_OK);

                result = CANTP_FRAME_STATE_OK;
            }

            break;
        }
        case BUFREQ_E_NOT_OK:
        case BUFREQ_E_BUSY:
        case BUFREQ_E_OVFL:
        default:
        {
            break;
        }
    }

    return result;
}

static CanTp_FrameStateType
CanTp_LDataIndRFF(CanTp_NSduType *pNSdu, const PduInfoType *pPduInfo, const PduLengthType nAeSize)
{
    PduLengthType header_size;
    PduLengthType payload_size;
    CanTp_FrameStateType result = CANTP_FRAME_STATE_INVALID;
    CanTp_NSduType *p_n_sdu = pNSdu;

    if (p_n_sdu->rx.shared.taskState == CANTP_PROCESSING)
    {
        /* SWS_CanTp_00057: Terminate the current reception, report an indication, with parameter
         * Result set to E_NOT_OK, to the upper layer, and process the SF/FF N-PDU as the start of a
         * new reception */
        PduR_CanTpRxIndication(p_n_sdu->rx.cfg->nSduId, E_NOT_OK);

        CanTp_ReportRuntimeError(CANTP_I_RX_FF, CANTP_RX_INDICATION_API_ID, CANTP_E_UNEXP_PDU);
    }
    else
    {
        CANTP_ENTER_CRITICAL_SECTION
        p_n_sdu->rx.shared.taskState = CANTP_PROCESSING;
        CANTP_EXIT_CRITICAL_SECTION
    }

    header_size = CANTP_FF_PCI_FIELD_SIZE + nAeSize;
    payload_size = CANTP_CAN_FRAME_SIZE - header_size;

    p_n_sdu->rx.buf.size = CanTp_DecodeDLValue(CANTP_N_PCI_TYPE_FF,
                                               p_n_sdu->rx.cfg->padding,
                                               &pPduInfo->SduDataPtr[nAeSize]);

    p_n_sdu->rx.sn = 0x00u;
    p_n_sdu->rx.wft_max = p_n_sdu->rx.cfg->wftMax;
    p_n_sdu->rx.bs = p_n_sdu->rx.shared.m_param.bs;

    p_n_sdu->rx.pdu_r_pdu_info.SduDataPtr = &pPduInfo->SduDataPtr[header_size];
    p_n_sdu->rx.pdu_r_pdu_info.SduLength = pPduInfo->SduLength - header_size;
    p_n_sdu->rx.pdu_r_pdu_info.MetaDataPtr = NULL_PTR;

    /* TODO: as I understand, the N_Br is the time allowed for the upper layer to provide the
     *  required buffer. thus, the N_Br timeout will be handled according to SWS_CanTp_00082. */

    /* SWS_CanTp_00166: At the reception of a FF or last CF of a block, the CanTp module shall start
     * a time-out N_Br before calling PduR_CanTpStartOfReception or PduR_CanTpCopyRxData.
     *
     * CanTp_StartNetworkLayerTimeout(p_n_sdu, CANTP_I_N_BR); */

    switch (PduR_CanTpStartOfReception(p_n_sdu->rx.cfg->nSduId,
                                       &p_n_sdu->rx.pdu_r_pdu_info,
                                       p_n_sdu->rx.buf.size,
                                       &p_n_sdu->rx.buf.rmng))
    {
        case BUFREQ_E_OVFL:
        {
            /* SWS_CanTp_00318: After the reception of a First Frame, if the function
             * PduR_CanTpStartOfReception() returns BUFREQ_E_OVFL to the CanTp module, the CanTp
             * module shall send a Flow Control N-PDU with overflow status (FC(OVFLW)) and abort the
             * N-SDU reception. */
            result = CANTP_RX_FRAME_STATE_FC_TX_REQUEST;
            p_n_sdu->rx.fs = CANTP_FLOW_STATUS_TYPE_OVFLW;

            break;
        }
        case BUFREQ_OK:
        {
            /* SWS_CanTp_00339: After the reception of a First Frame or Single Frame, if the
             * function PduR_CanTpStartOfReception() returns BUFREQ_OK with a smaller available
             * buffer size than needed for the already received data, the CanTp module shall abort
             * the reception of the N-SDU and call PduR_CanTpRxIndication() with the result
             * E_NOT_OK. */
            if (p_n_sdu->rx.buf.rmng < payload_size)
            {
                PduR_CanTpRxIndication(p_n_sdu->rx.cfg->nSduId, E_NOT_OK);

                result = CANTP_FRAME_STATE_ABORT;
            }
            else
            {
                result = CANTP_RX_FRAME_STATE_FC_TX_REQUEST;

                if (p_n_sdu->rx.buf.rmng < CanTp_GetRxBlockSize(p_n_sdu))
                {
                    /* SWS_CanTp_00082: After the reception of a First Frame, if the function
                     * PduR_CanTpStartOfReception() returns BUFREQ_OK with a smaller available
                     * buffer size than needed for the next block, the CanTp module shall start the
                     * timer N_Br. */
                    CanTp_StartNetworkLayerTimeout(p_n_sdu, CANTP_I_N_BR);

                    p_n_sdu->rx.fs = CANTP_FLOW_STATUS_TYPE_WT;
                }
                else
                {
                    p_n_sdu->rx.fs = CANTP_FLOW_STATUS_TYPE_CTS;
                }

                /* TODO: check the behavior to adopt if CanTp_CopyRxPayload does not return
                 *  BUFREQ_OK */
                (void)CanTp_CopyRxPayload(p_n_sdu);
            }

            break;
        }
        case BUFREQ_E_NOT_OK:
        {
            /* SWS_CanTp_00081: After the reception of a First Frame or Single Frame, if the
             * function PduR_CanTpStartOfReception()returns BUFREQ_E_NOT_OK to the CanTp module,
             * the CanTp module shall abort the reception of this N-SDU. No Flow Control will be
             * sent and PduR_CanTpRxIndication() will not be called in this case. */
            result = CANTP_FRAME_STATE_ABORT;

            break;
        }
        case BUFREQ_E_BUSY:
        default:
        {
            break;
        }
    }

    return result;
}

static CanTp_FrameStateType
CanTp_LDataIndRCF(CanTp_NSduType *pNSdu, const PduInfoType *pPduInfo, const PduLengthType nAeSize)
{
    PduLengthType header_size;
    CanTp_FrameStateType result = CANTP_FRAME_STATE_INVALID;
    CanTp_NSduType *p_n_sdu = pNSdu;

    CanTp_StopNetworkLayerTimeout(p_n_sdu, CANTP_I_N_CR);

    if (p_n_sdu->rx.shared.taskState == CANTP_PROCESSING)
    {
        /* If awaited, process the CF N_PDU in the on-going reception and perform the required
         * checks (e.g. SN in right order), otherwise ignore it. */
        if ((pPduInfo->SduDataPtr[nAeSize] & 0x0Fu) == ((p_n_sdu->rx.sn + 0x01u) & 0x0Fu))
        {
            header_size = CANTP_CF_PCI_FIELD_SIZE + nAeSize;

            p_n_sdu->rx.sn++;
            p_n_sdu->rx.bs--;

            p_n_sdu->rx.pdu_r_pdu_info.SduDataPtr = &pPduInfo->SduDataPtr[header_size];
            p_n_sdu->rx.pdu_r_pdu_info.SduLength = pPduInfo->SduLength - header_size;
            p_n_sdu->rx.pdu_r_pdu_info.MetaDataPtr = NULL_PTR;

            /* TODO: check the behavior to adopt if CanTp_CopyRxPayload does not return
             *  BUFREQ_OK */
            (void)CanTp_CopyRxPayload(p_n_sdu);

            if (p_n_sdu->rx.buf.size != 0x00u)
            {
                if (p_n_sdu->rx.bs == 0x00u)
                {
                    p_n_sdu->rx.bs = p_n_sdu->rx.shared.m_param.bs;

                    /* SWS_CanTp_00166: At the reception of a FF or last CF of a block, the CanTp
                     * module shall start a time-out N_Br before calling PduR_CanTpStartOfReception
                     * or PduR_CanTpCopyRxData. */
                    CanTp_StartNetworkLayerTimeout(p_n_sdu, CANTP_I_N_BR);
                    result = CANTP_RX_FRAME_STATE_FC_TX_REQUEST;
                }
                else
                {
                    CanTp_StartNetworkLayerTimeout(p_n_sdu, CANTP_I_N_CR);
                    result = CANTP_RX_FRAME_STATE_CF_RX_INDICATION;
                }
            }
            else
            {
                PduR_CanTpRxIndication(p_n_sdu->rx.cfg->nSduId, E_OK);
                result = CANTP_FRAME_STATE_OK;
            }
        }
    }

    return result;
}

static CanTp_FrameStateType CanTp_LDataIndTFC(CanTp_NSduType *pNSdu, const PduInfoType *pPduInfo)
{
    CanTp_NSduType *p_n_sdu = pNSdu;

    CanTp_StopNetworkLayerTimeout(p_n_sdu, CANTP_I_N_BS);

    p_n_sdu->tx.fs = (CanTp_FlowStatusType)pPduInfo->SduDataPtr[0x00u] & 0x0Fu;
    p_n_sdu->tx.bs = pPduInfo->SduDataPtr[0x01u];
    p_n_sdu->tx.target_st_min = CanTp_DecodeSTMinValue(pPduInfo->SduDataPtr[0x02u]);

    /* SWS_CanTp_00315: the CanTp module shall start a timeout observation for N_Bs time at
     * confirmation of the FF transmission, last CF of a block transmission and at each
     * indication of FC with FS=WT (i.e. time until reception of the next FC). */
    if (p_n_sdu->tx.fs == CANTP_FLOW_STATUS_TYPE_WT)
    {
        CanTp_StartNetworkLayerTimeout(p_n_sdu, CANTP_I_N_BS);
    }

    /* ISO15765:
     * 00: The BS parameter value zero (0) shall be used to indicate to the sender that no more
     * FC frames shall be sent during the transmission of the segmented message. The sending
     * network layer entity shall send all remaining consecutive frames without any stop for
     * further FC frames from the receiving network layer entity.
     * 01-FF: This range of BS parameter values shall be used to indicate to the sender the
     * maximum number of consecutive frames that can be received without an intermediate FC
     * frame from the receiving network entity.*/
    if (p_n_sdu->tx.bs == 0x00u)
    {
        p_n_sdu->tx.bs = CANTP_BS_INFINITE;
    }

    return CANTP_TX_FRAME_STATE_CF_TX_REQUEST;
}

static CanTp_FrameStateType CanTp_LDataConTSF(CanTp_NSduType *pNSdu)
{
    CanTp_NSduType *p_n_sdu = pNSdu;

    CanTp_StopNetworkLayerTimeout(p_n_sdu, CANTP_I_N_AS);

    return CANTP_FRAME_STATE_OK;
}

static CanTp_FrameStateType CanTp_LDataConTFF(CanTp_NSduType *pNSdu)
{
    CanTp_NSduType *p_n_sdu = pNSdu;

    CanTp_StopNetworkLayerTimeout(p_n_sdu, CANTP_I_N_AS);

    /* SWS_CanTp_00315: the CanTp module shall start a timeout observation for N_Bs time at
     * confirmation of the FF transmission, last CF of a block transmission and at each indication
     * of FC with FS=WT (i.e. time until reception of the next FC). */
    CanTp_StartNetworkLayerTimeout(p_n_sdu, CANTP_I_N_BS);

    return CANTP_TX_FRAME_STATE_FC_RX_INDICATION;
}

static CanTp_FrameStateType CanTp_LDataConTCF(CanTp_NSduType *pNSdu)
{
    CanTp_FrameStateType result;
    CanTp_NSduType *p_n_sdu = pNSdu;

    CanTp_StopNetworkLayerTimeout(p_n_sdu, CANTP_I_N_AS);

    /* ISO15765: the measurement of the STmin starts after completion of transmission of a
     * ConsecutiveFrame (CF) and ends at the request for the transmission of the next CF. */
    CanTp_StartFlowControlTimeout(p_n_sdu);

    if (p_n_sdu->tx.buf.size > 0x00u)
    {
        if (p_n_sdu->tx.bs != CANTP_BS_INFINITE)
        {
            p_n_sdu->tx.bs--;
        }

        if (p_n_sdu->tx.bs != 0x00u)
        {
            result = CANTP_TX_FRAME_STATE_CF_TX_REQUEST;
        }
        else
        {
            /* SWS_CanTp_00315: the CanTp module shall start a timeout observation for N_Bs time at
             * confirmation of the FF transmission, last CF of a block transmission and at each
             * indication of FC with FS=WT (i.e. time until reception of the next FC). */
            CanTp_StartNetworkLayerTimeout(p_n_sdu, CANTP_I_N_BS);

            result = CANTP_TX_FRAME_STATE_FC_RX_INDICATION;
        }
    }
    else
    {
        result = CANTP_FRAME_STATE_OK;
    }

    return result;
}

static CanTp_FrameStateType CanTp_LDataConRFC(CanTp_NSduType *pNSdu)
{
    CanTp_FrameStateType result;
    CanTp_NSduType *p_n_sdu = pNSdu;

    CanTp_StopNetworkLayerTimeout(p_n_sdu, CANTP_I_N_AR);
    CanTp_StartNetworkLayerTimeout(p_n_sdu, CANTP_I_N_CR);

    if (CanTp_NetworkLayerIsActive(p_n_sdu, CANTP_I_N_BR) == FALSE)
    {
        result = CANTP_RX_FRAME_STATE_CF_RX_INDICATION;
    }
    else
    {
        result = CANTP_RX_FRAME_STATE_FC_TX_REQUEST;
    }

    return result;
}

void CanTp_RxIndication(PduIdType rxPduId, const PduInfoType *pPduInfo)
{
    CanTp_FrameStateType next_state;
    CanTp_NPciType pci;
    PduLengthType n_ae_field_size;
    CanTp_NSduType *p_n_sdu;

    if (pPduInfo != NULL_PTR)
    {
        if (CanTp_GetNSduFromPduId(rxPduId, &p_n_sdu) == E_OK)
        {
            if ((p_n_sdu->dir & CANTP_DIRECTION_RX) != 0x00u)
            {
                if (CanTp_DecodeNAIValue(p_n_sdu->rx.cfg->af, &n_ae_field_size) == E_OK)
                {
                    if (CanTp_DecodePCIValue(&pci, &pPduInfo->SduDataPtr[n_ae_field_size]) == E_OK)
                    {
                        /* SWS_CanTp_00345: If frames with a payload <= 8 (either CAN 2.0 frames or small CAN FD
                     * frames) are used for a Rx N-SDU and CanTpRxPaddingActivation is equal to CANTP_ON, then
                     * CanTp receives by means of CanTp_RxIndication() call an SF Rx N-PDU belonging to that
                     * N-SDU, with a length smaller than eight bytes (i.e. PduInfoPtr.SduLength < 8), CanTp
                     * shall reject the reception. The runtime error code CANTP_E_PADDING shall be reported to
                     * the Default Error Tracer. */
                        if (((CanTp_StateType)p_n_sdu->rx.cfg->padding ==
                             (CanTp_StateType)CANTP_ON) &&
                            (pPduInfo->SduLength < CANTP_CAN_FRAME_SIZE))
                        {
                            PduR_CanTpRxIndication(p_n_sdu->rx.cfg->nSduId, E_NOT_OK);

                            CanTp_ReportRuntimeError(0x00u, CANTP_RX_INDICATION_API_ID,
                                                     CANTP_E_PADDING);

                            next_state = CANTP_FRAME_STATE_OK;
                        }
                            /* SWS_CanTp_00093: If a multiple segmented session occurs (on both receiver and sender
                             * side) with a handle whose communication type is functional, the CanTp module shall
                             * reject the request and report the runtime error code CANTP_E_INVALID_TATYPE to the
                             * Default Error Tracer. */
                        else if ((p_n_sdu->rx.cfg->taType == CANTP_FUNCTIONAL) &&
                                 (pci == CANTP_N_PCI_TYPE_FF))
                        {
                            CanTp_ReportRuntimeError(0x00u, CANTP_RX_INDICATION_API_ID,
                                                     CANTP_E_INVALID_TATYPE);

                            next_state = CANTP_FRAME_STATE_OK;
                        }
                        else if (pci == CANTP_N_PCI_TYPE_SF)
                        {
                            next_state = CanTp_LDataIndRSF(p_n_sdu, pPduInfo, n_ae_field_size);
                        }
                        else if (pci == CANTP_N_PCI_TYPE_FF)
                        {
                            next_state = CanTp_LDataIndRFF(p_n_sdu, pPduInfo, n_ae_field_size);
                        }
                        else if ((pci == CANTP_N_PCI_TYPE_CF) &&
                                 (p_n_sdu->rx.shared.state ==
                                  CANTP_RX_FRAME_STATE_CF_RX_INDICATION))
                        {
                            next_state = CanTp_LDataIndRCF(p_n_sdu, pPduInfo, n_ae_field_size);
                        }
                        else
                        {
                            next_state = CANTP_FRAME_STATE_INVALID;
                        }

                        if (next_state != CANTP_FRAME_STATE_INVALID)
                        {
                            p_n_sdu->rx.shared.state = next_state;
                        }
                    }
                }
            }

            if ((p_n_sdu->dir & CANTP_DIRECTION_TX) != 0x00u)
            {
                if (CanTp_DecodeNAIValue(p_n_sdu->tx.cfg->af, &n_ae_field_size) == E_OK)
                {
                    if (CanTp_DecodePCIValue(&pci, &pPduInfo->SduDataPtr[n_ae_field_size]) == E_OK)
                    {
                        if (p_n_sdu->tx.shared.state == CANTP_TX_FRAME_STATE_FC_RX_INDICATION)
                        {
                            p_n_sdu->tx.shared.state = CanTp_LDataIndTFC(p_n_sdu, pPduInfo);
                        }
                    }
                }
            }
        }
        else
        {
            CanTp_ReportError(0x00u, CANTP_RX_INDICATION_API_ID, CANTP_E_INVALID_RX_ID);
        }
    }
    else
    {
        CanTp_ReportError(0x00u, CANTP_RX_INDICATION_API_ID, CANTP_E_PARAM_POINTER);
    }
}

void CanTp_TxConfirmation(PduIdType txPduId, Std_ReturnType result)
{
    CanTp_FrameStateType next_state;
    CanTp_NSduType *p_n_sdu;

    if (CanTp_GetNSduFromPduId(txPduId, &p_n_sdu) == E_OK)
    {
        if (result == E_OK)
        {
            if ((p_n_sdu->dir & CANTP_DIRECTION_RX) != 0x00u)
            {
                if (p_n_sdu->rx.shared.state == CANTP_RX_FRAME_STATE_FC_TX_CONFIRMATION)
                {
                    next_state = CanTp_LDataConRFC(p_n_sdu);
                }
                else
                {
                    next_state = CANTP_FRAME_STATE_INVALID;
                }

                if (next_state != CANTP_FRAME_STATE_INVALID)
                {
                    p_n_sdu->rx.shared.state = next_state;
                }
            }

            if ((p_n_sdu->dir & CANTP_DIRECTION_TX) != 0x00u)
            {
                if (p_n_sdu->tx.shared.state == CANTP_TX_FRAME_STATE_SF_TX_CONFIRMATION)
                {
                    next_state = CanTp_LDataConTSF(p_n_sdu);
                }
                else if (p_n_sdu->tx.shared.state == CANTP_TX_FRAME_STATE_FF_TX_CONFIRMATION)
                {
                    next_state = CanTp_LDataConTFF(p_n_sdu);
                }
                else if (p_n_sdu->tx.shared.state == CANTP_TX_FRAME_STATE_CF_TX_CONFIRMATION)
                {
                    next_state = CanTp_LDataConTCF(p_n_sdu);
                }
                else
                {
                    next_state = CANTP_FRAME_STATE_INVALID;
                }

                if (next_state != CANTP_FRAME_STATE_INVALID)
                {
                    p_n_sdu->tx.shared.state = next_state;
                }
            }
        }
        else
        {
            /* SWS_CanTp_00355: CanTp shall abort the corresponding session, when
             * CanTp_TxConfirmation() is called with the result E_NOT_OK. */
            CanTp_AbortTxSession(p_n_sdu, CANTP_I_NONE, FALSE);
        }
    }
}

/** @} */


/*-----------------------------------------------------------------------------------------------*/
/* local function definitions (static).                                                          */
/*-----------------------------------------------------------------------------------------------*/

/**
 * @addtogroup CANTP_C_LFDEF
 * @{
 */

static Std_ReturnType CanTp_GetNSduFromPduId(PduIdType pduId, CanTp_NSduType **pNSdu)
{
    Std_ReturnType tmp_return = E_NOT_OK;
    CanTp_NSduType *p_n_sdu;
    CanTp_ChannelRtType *p_channel_rt;
    uint32_least channel_idx;

    for (channel_idx = 0x00u; channel_idx < (uint32_least)CANTP_MAX_NUM_OF_CHANNEL; channel_idx++)
    {
        p_channel_rt = &CanTp_Rt[channel_idx];

        if (pduId < (sizeof(p_channel_rt->sdu) / sizeof(p_channel_rt->sdu[0x00u])))
        {
            p_n_sdu = &p_channel_rt->sdu[pduId];

            if (((p_n_sdu->rx.cfg != NULL_PTR) && (p_n_sdu->rx.cfg->nSduId == pduId)) ||
                ((p_n_sdu->tx.cfg != NULL_PTR) && (p_n_sdu->tx.cfg->nSduId == pduId)))
            {
                *pNSdu = p_n_sdu;
                tmp_return = E_OK;

                break;
            }
        }
    }

    return tmp_return;
}

static PduLengthType CanTp_GetRxBlockSize(const CanTp_NSduType *pNSdu)
{
    PduLengthType result;
    PduLengthType n_ae_field_size;
    (void)CanTp_DecodeNAIValue(pNSdu->rx.cfg->af, &n_ae_field_size);
    const PduLengthType header_size = CANTP_CF_PCI_FIELD_SIZE + n_ae_field_size;
    const PduLengthType payload_size = CANTP_CAN_FRAME_SIZE - header_size;
    const PduLengthType full_bs = pNSdu->rx.shared.m_param.bs * payload_size;
    const PduLengthType last_bs = pNSdu->rx.buf.size;

    if ((last_bs < full_bs) || (full_bs == 0x00u))
    {
        result = last_bs;
    }
    else
    {
        result = full_bs;
    }

    return result;
}

static Std_ReturnType CanTp_DecodeNAIValue(const CanTp_AddressingFormatType af,
                                           PduLengthType *pPduLength)
{
    Std_ReturnType result = E_NOT_OK;

    if (pPduLength != NULL_PTR)
    {
        switch (af)
        {
            case CANTP_EXTENDED:
            case CANTP_MIXED:
            case CANTP_MIXED29BIT:
            {
                *pPduLength = 0x01u;
                result = E_OK;

                break;
            }
            case CANTP_STANDARD:
            case CANTP_NORMALFIXED:
            {
                *pPduLength = 0x00u;
                result = E_OK;

                break;
            }
            default:
            {
                break;
            }
        }
    }

    return result;
}

static Std_ReturnType CanTp_EncodeNAIValue(const CanTp_AddressingFormatType af,
                                           const CanTp_NAeType *pNAe,
                                           const CanTp_NTaType *pNTa,
                                           uint8 *pBuffer,
                                           PduLengthType *pOfs)
{
    Std_ReturnType result;
    PduLengthType ofs = *pOfs;

    /* SWS_CanTp_00281: if the message is configured to use an extended or a mixed addressing
     * format, the CanTp module must fill the first byte of each transmitted segment (SF, FF and CF)
     * with the N_TA (in case of extended addressing) or N_AE (in case of mixed addressing) value.
     * Therefore a CAN NSduId may also be related to a N_TA or N_AE value.*/
    if ((af == CANTP_EXTENDED) && (pNTa != NULL_PTR))
    {
        pBuffer[0x00u] = pNTa->nTa;
        ofs += 0x01u;

        result = E_OK;
    }
    else if (((af == CANTP_MIXED) || (af == CANTP_MIXED29BIT)) && (pNAe != NULL_PTR))
    {
        pBuffer[0x00u] = pNAe->nAe;
        ofs += 0x01u;

        result = E_OK;
    }
    else if ((af == CANTP_STANDARD) || (af == CANTP_NORMALFIXED))
    {
        result = E_OK;
    }
    else
    {
        result = E_NOT_OK;
    }

    *pOfs = ofs;

    return result;
}

static Std_ReturnType CanTp_DecodePCIValue(CanTp_NPciType *pPci, const uint8 *pData)
{
    Std_ReturnType tmp_return = E_NOT_OK;
    CanTp_NPciType pci;

    if ((pPci != NULL_PTR) && (pData != NULL_PTR))
    {
        pci = (CanTp_NPciType)((uint8)(pData[0x00u] >> 0x04u) & 0x0Fu);

        if ((pci == CANTP_N_PCI_TYPE_SF) ||
            (pci == CANTP_N_PCI_TYPE_FF) ||
            (pci == CANTP_N_PCI_TYPE_CF) ||
            (pci == CANTP_N_PCI_TYPE_FC))
        {
            *pPci = pci;
            tmp_return = E_OK;
        }
    }

    return tmp_return;
}

static PduLengthType CanTp_DecodeDLValue(const CanTp_NPciType frameType,
                                         const CanTp_RxPaddingActivationType padding,
                                         const uint8 *pData)
{
    PduLengthType result;

    result = (PduLengthType)pData[0x00u] & 0x0Fu;

    if (frameType == CANTP_N_PCI_TYPE_FF)
    {
        result = (PduLengthType)(result << 0x08u) | (PduLengthType)pData[0x01u];
    }

    /* SWS_CanTp_00350: The received data link layer data length (RX_DL) shall be
     * derived from the first received payload length of the CAN frame/PDU (CAN_DL) as
     * follows:
     * - For CAN_DL values less than or equal to eight bytes the RX_DL value shall be
     *   eight.
     * - For CAN_DL values greater than eight bytes the RX_DL value equals the CAN_DL
     *   value.*/
    if ((result < CANTP_CAN_FRAME_SIZE) && ((CanTp_StateType)padding == (CanTp_StateType)CANTP_ON))
    {
        result = CANTP_CAN_FRAME_SIZE;
    }

    return result;
}

static uint32_least CanTp_DecodeSTMinValue(const uint8 data)
{
    uint32_least result;

    /* ISO15765: the units of STmin in the range 00 hex – 7F hex are absolute milliseconds (ms). */
    if (data <= 0x7Fu)
    {
        result = CanTp_ConvertMsToUs((uint32_least)data);
    }
    /* ISO15765: the units of STmin in the range F1 hex – F9 hex are even 100 microseconds (μs),
     * where parameter value F1 hex represents 100 μs and parameter value F9 hex represents 900 μs.
     */
    else if ((data >= 0xF1u) && (data <= 0xF9u))
    {
        result = CanTp_ConvertUsToUs(((uint32_least)data & (uint32_least)0x0Fu) * 100u);
    }
    /* ISO15765: if an FC N_PDU message is received with a reserved ST parameter value, then the
     * sending network entity shall use the longest ST value specified by this part of ISO 15765
     * (7F hex – 127 ms) instead of the value received from the receiving network entity for the
     * duration of the ongoing segmented message transmission. */
    else
    {
        result = CanTp_ConvertMsToUs(0x7Fu);
    }

    return result;
}

static uint8 CanTp_EncodeSTMinValue(const uint16 value)
{
    uint8 result;

    if (CanTp_ConvertUsToMs(value) <= 0x7Fu)
    {
        result = (uint8)CanTp_ConvertUsToMs(value);
    }
    else if ((value == 100u) ||
             (value == 200u) ||
             (value == 300u) ||
             (value == 400u) ||
             (value == 500u) ||
             (value == 600u) ||
             (value == 700u) ||
             (value == 800u) ||
             (value == 900u))
    {
        result = (uint8)(0x00F0u | (value / 100u));
    }
    else
    {
        result = 0x7Fu;
    }

    return result;
}

static void CanTp_AbortRxSession(CanTp_NSduType *pNSdu, const uint8 instanceId, const boolean confirm)
{
    pNSdu->rx.shared.taskState = CANTP_WAIT;

    if (confirm == TRUE)
    {
        PduR_CanTpRxIndication(pNSdu->rx.cfg->nSduId, E_NOT_OK);
    }

    if (instanceId != CANTP_I_NONE)
    {
        /* SWS_CanTp_00229 if the task was aborted due to As, Bs, Cs, Ar, Br, Cr timeout, the CanTp
         * module shall raise the DET error CANTP_E_RX_COM (in case of a reception operation) or
         * CANTP_E_TX_COM (in case of a transmission operation). If the task was aborted due to any
         * other protocol error, the CanTp module shall raise the runtime error code CANTP_E_COM to
         * the Default Error Tracer. */
        CanTp_ReportError(instanceId, 0x00u, CANTP_E_RX_COM);
    }
}

static void CanTp_AbortTxSession(CanTp_NSduType *pNSdu, const uint8 instanceId, boolean confirm)
{
    pNSdu->tx.taskState = CANTP_WAIT;

    if (confirm == TRUE)
    {
        PduR_CanTpTxConfirmation(pNSdu->tx.cfg->nSduId, E_NOT_OK);
    }

    if (instanceId != CANTP_I_NONE)
    {
        /* SWS_CanTp_00229 if the task was aborted due to As, Bs, Cs, Ar, Br, Cr timeout, the CanTp
         * module shall raise the DET error CANTP_E_RX_COM (in case of a reception operation) or
         * CANTP_E_TX_COM (in case of a transmission operation). If the task was aborted due to any
         * other protocol error, the CanTp module shall raise the runtime error code CANTP_E_COM to
         * the Default Error Tracer. */
        CanTp_ReportError(instanceId, 0x00u, CANTP_E_TX_COM);
    }
}

static void CanTp_TransmitRxCANData(CanTp_NSduType *pNSdu)
{
    CanTp_StartNetworkLayerTimeout(pNSdu, CANTP_I_N_AR);

    if (CanIf_Transmit(pNSdu->rx.cfg->rxNSduRef, &pNSdu->rx.can_if_pdu_info) != E_OK)
    {
        CanTp_AbortRxSession(pNSdu, CANTP_I_NONE, FALSE);
    }
}

static void CanTp_TransmitTxCANData(CanTp_NSduType *pNSdu)
{
    CanTp_StartNetworkLayerTimeout(pNSdu, CANTP_I_N_AS);

    if (CanIf_Transmit((PduIdType)pNSdu->tx.cfg->txNSduRef, &pNSdu->tx.can_if_pdu_info) != E_OK)
    {
        CanTp_AbortTxSession(pNSdu, CANTP_I_NONE, FALSE);
    }
}

static void CanTp_PerformStepRx(CanTp_NSduType *pNSdu)
{
    CanTp_NSduType *p_n_sdu = pNSdu;

    if (CanTp_NetworkLayerIsActive(p_n_sdu, CANTP_I_N_BR) == TRUE)
    {
        /* SWS_CanTp_00222: wWhile the timer N_Br is active, the CanTp module shall call the service
         * PduR_CanTpCopyRxData() with a data length 0 (zero) and NULL_PTR as data buffer during
         * each processing of the MainFunction. */
        p_n_sdu->rx.pdu_r_pdu_info.SduLength = 0x00u;
        p_n_sdu->rx.pdu_r_pdu_info.SduDataPtr = NULL_PTR;
        (void)CanTp_CopyRxPayload(p_n_sdu);
    }

    if (CanTp_NetworkLayerTimeoutExpired(p_n_sdu, CANTP_I_N_BR) == TRUE)
    {
        CanTp_ReportError(CANTP_I_N_BR, 0x00u, CANTP_E_RX_COM);
    }

    if (CanTp_NetworkLayerTimeoutExpired(p_n_sdu, CANTP_I_N_AR) == TRUE)
    {
        CanTp_AbortRxSession(pNSdu, CANTP_I_N_AR, TRUE);
    }
    else if (CanTp_NetworkLayerTimeoutExpired(p_n_sdu, CANTP_I_N_CR) == TRUE)
    {
        CanTp_AbortRxSession(pNSdu, CANTP_I_N_CR, TRUE);
    }
    else
    {
        switch (p_n_sdu->rx.shared.state)
        {
            case CANTP_RX_FRAME_STATE_FC_TX_REQUEST:
            {
                p_n_sdu->rx.shared.state = CanTp_LDataReqRFC(p_n_sdu);

                switch (p_n_sdu->rx.shared.state)
                {
                    case CANTP_RX_FRAME_STATE_FC_TX_CONFIRMATION:
                    {
                        CanTp_TransmitRxCANData(p_n_sdu);

                        break;
                    }
                    case CANTP_RX_FRAME_STATE_FC_OVFLW_TX_CONFIRMATION:
                    {
                        CanTp_TransmitRxCANData(p_n_sdu);

                        CanTp_AbortRxSession(pNSdu, CANTP_I_N_BUFFER_OVFLW, FALSE);

                        break;
                    }
                    case CANTP_FRAME_STATE_ABORT:
                    {
                        CanTp_AbortRxSession(pNSdu, CANTP_I_NONE, TRUE);

                        break;
                    }
                    default:
                    {
                        break;
                    }
                }

                break;
            }
            case CANTP_FRAME_STATE_ABORT:
            {
                CanTp_AbortRxSession(p_n_sdu, CANTP_I_NONE, FALSE);

                break;
            }
            case CANTP_FRAME_STATE_OK:
            {
                p_n_sdu->rx.shared.taskState = CANTP_WAIT;

                break;
            }
            case CANTP_FRAME_STATE_INVALID:
            case CANTP_RX_FRAME_STATE_FC_TX_CONFIRMATION:
            case CANTP_RX_FRAME_STATE_FC_OVFLW_TX_CONFIRMATION:
            case CANTP_RX_FRAME_STATE_CF_RX_INDICATION:
            case CANTP_TX_FRAME_STATE_SF_TX_REQUEST:
            case CANTP_TX_FRAME_STATE_SF_TX_CONFIRMATION:
            case CANTP_TX_FRAME_STATE_FF_TX_REQUEST:
            case CANTP_TX_FRAME_STATE_FF_TX_CONFIRMATION:
            case CANTP_TX_FRAME_STATE_CF_TX_REQUEST:
            case CANTP_TX_FRAME_STATE_CF_TX_CONFIRMATION:
            case CANTP_TX_FRAME_STATE_FC_RX_INDICATION:
            default:
            {
                break;
            }
        }
    }
}

static void CanTp_PerformStepTx(CanTp_NSduType *pNSdu)
{
    CanTp_NSduType *p_n_sdu = pNSdu;

    if (CanTp_NetworkLayerTimeoutExpired(p_n_sdu, CANTP_I_N_AS) == TRUE)
    {
        CanTp_AbortTxSession(pNSdu, CANTP_I_N_AS, TRUE);
    }
    else if (CanTp_NetworkLayerTimeoutExpired(p_n_sdu, CANTP_I_N_BS) == TRUE)
    {
        /* SWS_CanTp_00316: in case of N_Bs timeout occurrence the CanTp module shall abort
         * transmission of this message and notify the upper layer by calling the callback function
         * PduR_CanTpTxConfirmation() with the result E_NOT_OK. */
        CanTp_AbortTxSession(pNSdu, CANTP_I_N_BS, TRUE);
    }
    else if (CanTp_NetworkLayerTimeoutExpired(p_n_sdu, CANTP_I_N_CS) == TRUE)
    {
        /* SWS_CanTp_00280: if data is not available within N_Cs timeout the CanTp module shall
         * notify the upper layer of this failure by calling the callback function
         * PduR_CanTpTxConfirmation with the result E_NOT_OK. */
        CanTp_AbortTxSession(p_n_sdu, CANTP_I_N_CS, TRUE);
    }
    else
    {
        switch (p_n_sdu->tx.shared.state)
        {
            case CANTP_TX_FRAME_STATE_SF_TX_REQUEST:
            {
                p_n_sdu->tx.shared.state = CanTp_LDataReqTSF(p_n_sdu);

                if (p_n_sdu->tx.shared.state == CANTP_TX_FRAME_STATE_SF_TX_CONFIRMATION)
                {
                    CanTp_TransmitTxCANData(p_n_sdu);
                }

                break;
            }
            case CANTP_TX_FRAME_STATE_FF_TX_REQUEST:
            {
                p_n_sdu->tx.shared.state = CanTp_LDataReqTFF(p_n_sdu);

                if (p_n_sdu->tx.shared.state == CANTP_TX_FRAME_STATE_FF_TX_CONFIRMATION)
                {
                    CanTp_TransmitTxCANData(p_n_sdu);
                }

                break;
            }
            case CANTP_TX_FRAME_STATE_CF_TX_REQUEST:
            {
                if ((CanTp_FlowControlExpired(p_n_sdu) == TRUE) ||
                    (CanTp_FlowControlActive(p_n_sdu) == FALSE))
                {
                    p_n_sdu->tx.shared.state = CanTp_LDataReqTCF(p_n_sdu);

                    if (p_n_sdu->tx.shared.state == CANTP_TX_FRAME_STATE_CF_TX_CONFIRMATION)
                    {
                        CanTp_TransmitTxCANData(p_n_sdu);
                    }
                }

                break;
            }
            case CANTP_FRAME_STATE_OK:
            {
                /* SWS_CanTp_00090: when the transport transmission session is successfully
                 * completed, the CanTp module shall call a notification service of the upper layer,
                 * PduR_CanTpTxConfirmation(), with the result E_OK. */
                PduR_CanTpTxConfirmation(p_n_sdu->tx.cfg->nSduId, E_OK);

                p_n_sdu->tx.taskState = CANTP_WAIT;

                break;
            }
            case CANTP_FRAME_STATE_INVALID:
            case CANTP_FRAME_STATE_ABORT:
            case CANTP_RX_FRAME_STATE_CF_RX_INDICATION:
            case CANTP_RX_FRAME_STATE_FC_TX_REQUEST:
            case CANTP_RX_FRAME_STATE_FC_TX_CONFIRMATION:
            case CANTP_RX_FRAME_STATE_FC_OVFLW_TX_CONFIRMATION:
            case CANTP_TX_FRAME_STATE_SF_TX_CONFIRMATION:
            case CANTP_TX_FRAME_STATE_FF_TX_CONFIRMATION:
            case CANTP_TX_FRAME_STATE_FC_RX_INDICATION:
            case CANTP_TX_FRAME_STATE_CF_TX_CONFIRMATION:
            default:
            {
                break;
            }
        }
    }
}

static BufReq_ReturnType CanTp_CopyRxPayload(CanTp_NSduType *pNSdu)
{
    BufReq_ReturnType result;

    result = PduR_CanTpCopyRxData(pNSdu->rx.cfg->nSduId,
                                  &pNSdu->rx.pdu_r_pdu_info,
                                  &pNSdu->rx.buf.rmng);

    if (result == BUFREQ_OK)
    {
        pNSdu->rx.buf.size -= pNSdu->rx.pdu_r_pdu_info.SduLength;
    }

    return result;
}

static BufReq_ReturnType CanTp_CopyTxPayload(CanTp_NSduType *pNSdu, PduLengthType *pOfs)
{
    BufReq_ReturnType result;
    PduInfoType tmp_pdu;
    PduLengthType ofs = *pOfs;
    CanTp_NSduType *p_n_sdu = pNSdu;
    tmp_pdu.SduDataPtr = &p_n_sdu->tx.buf.can[ofs];

    if (p_n_sdu->tx.buf.size <= (CANTP_CAN_FRAME_SIZE - ofs))
    {
        tmp_pdu.SduLength = p_n_sdu->tx.buf.size;
    }
    else
    {
        tmp_pdu.SduLength = CANTP_CAN_FRAME_SIZE - ofs;
    }

    CanTp_StartNetworkLayerTimeout(p_n_sdu, CANTP_I_N_CS);

    /* SWS_CanTp_00272: the API PduR_CanTpCopyTxData() contains a parameter used for the recovery
     * mechanism – ‘retry’. Because ISO 15765-2 does not support such a mechanism, the CAN Transport
     * Layer does not implement any kind of recovery. Thus, the parameter is always set to NULL
     * pointer. */
    result = PduR_CanTpCopyTxData(pNSdu->tx.cfg->nSduId, &tmp_pdu, NULL_PTR, &pNSdu->tx.buf.rmng);

    switch (result)
    {
        case BUFREQ_OK:
        {
            CanTp_StopNetworkLayerTimeout(p_n_sdu, CANTP_I_N_CS);

            ofs += tmp_pdu.SduLength;
            p_n_sdu->tx.buf.size -= tmp_pdu.SduLength;

            *pOfs = ofs;

            break;
        }
        case BUFREQ_E_NOT_OK:
        {
            /* SWS_CanTp_00087: if PduR_CanTpCopyTxData() returns BUFREQ_E_NOT_OK, the CanTp module
             * shall abort the transmit request and notify the upper layer of this failure by
             * calling the callback function PduR_CanTpTxConfirmation() with the result E_NOT_OK. */
            CanTp_AbortTxSession(p_n_sdu, CANTP_I_NONE, TRUE);

            break;
        }
        case BUFREQ_E_BUSY:
        case BUFREQ_E_OVFL:
        default:
        {
            break;
        }
    }

    return result;
}

static void CanTp_SetPadding(uint8 *pBuffer, PduLengthType *pOfs, const uint8 value)
{
    uint8 *p_buffer = pBuffer;
    PduLengthType ofs = *pOfs;

    for (; ofs < CANTP_CAN_FRAME_SIZE; ofs++)
    {
        p_buffer[ofs] = value;
    }

    *pOfs = ofs;
}

/** @} */

#ifdef __cplusplus

}

#endif /* ifdef __cplusplus */


/************************************************************/

static void *_cffi_types[] = {
/*  0 */ _CFFI_OP(_CFFI_OP_FUNCTION, 59), // BufReq_ReturnType()(unsigned short, PduInfoType const *, RetryInfoType const *, unsigned int *)
/*  1 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 6), // unsigned short
/*  2 */ _CFFI_OP(_CFFI_OP_POINTER, 82), // PduInfoType const *
/*  3 */ _CFFI_OP(_CFFI_OP_POINTER, 83), // RetryInfoType const *
/*  4 */ _CFFI_OP(_CFFI_OP_POINTER, 14), // unsigned int *
/*  5 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  6 */ _CFFI_OP(_CFFI_OP_FUNCTION, 59), // BufReq_ReturnType()(unsigned short, PduInfoType const *, unsigned int *)
/*  7 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 6),
/*  8 */ _CFFI_OP(_CFFI_OP_NOOP, 2),
/*  9 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 10 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 11 */ _CFFI_OP(_CFFI_OP_FUNCTION, 59), // BufReq_ReturnType()(unsigned short, PduInfoType const *, unsigned int, unsigned int *)
/* 12 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 6),
/* 13 */ _CFFI_OP(_CFFI_OP_NOOP, 2),
/* 14 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8), // unsigned int
/* 15 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 16 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 17 */ _CFFI_OP(_CFFI_OP_FUNCTION, 14), // unsigned int()(unsigned short)
/* 18 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 6),
/* 19 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 20 */ _CFFI_OP(_CFFI_OP_FUNCTION, 14), // unsigned int()(unsigned short, PduInfoType const *)
/* 21 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 6),
/* 22 */ _CFFI_OP(_CFFI_OP_NOOP, 2),
/* 23 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 24 */ _CFFI_OP(_CFFI_OP_FUNCTION, 14), // unsigned int()(unsigned short, TPParameterType, unsigned short *)
/* 25 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 6),
/* 26 */ _CFFI_OP(_CFFI_OP_ENUM, 6), // TPParameterType
/* 27 */ _CFFI_OP(_CFFI_OP_POINTER, 1), // unsigned short *
/* 28 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 29 */ _CFFI_OP(_CFFI_OP_FUNCTION, 14), // unsigned int()(unsigned short, TPParameterType, unsigned short)
/* 30 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 6),
/* 31 */ _CFFI_OP(_CFFI_OP_NOOP, 26),
/* 32 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 6),
/* 33 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 34 */ _CFFI_OP(_CFFI_OP_FUNCTION, 14), // unsigned int()(unsigned short, unsigned char, unsigned char, unsigned char)
/* 35 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 6),
/* 36 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 4), // unsigned char
/* 37 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 4),
/* 38 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 4),
/* 39 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 40 */ _CFFI_OP(_CFFI_OP_FUNCTION, 95), // void()(CanTp_ConfigType const *)
/* 41 */ _CFFI_OP(_CFFI_OP_POINTER, 65), // CanTp_ConfigType const *
/* 42 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 43 */ _CFFI_OP(_CFFI_OP_FUNCTION, 95), // void()(Std_VersionInfoType *)
/* 44 */ _CFFI_OP(_CFFI_OP_POINTER, 84), // Std_VersionInfoType *
/* 45 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 46 */ _CFFI_OP(_CFFI_OP_FUNCTION, 95), // void()(unsigned short, PduInfoType const *)
/* 47 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 6),
/* 48 */ _CFFI_OP(_CFFI_OP_NOOP, 2),
/* 49 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 50 */ _CFFI_OP(_CFFI_OP_FUNCTION, 95), // void()(unsigned short, unsigned int)
/* 51 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 6),
/* 52 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 53 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 54 */ _CFFI_OP(_CFFI_OP_FUNCTION, 95), // void()(void)
/* 55 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 56 */ _CFFI_OP(_CFFI_OP_POINTER, 0), // BufReq_ReturnType(*)(unsigned short, PduInfoType const *, RetryInfoType const *, unsigned int *)
/* 57 */ _CFFI_OP(_CFFI_OP_POINTER, 6), // BufReq_ReturnType(*)(unsigned short, PduInfoType const *, unsigned int *)
/* 58 */ _CFFI_OP(_CFFI_OP_POINTER, 11), // BufReq_ReturnType(*)(unsigned short, PduInfoType const *, unsigned int, unsigned int *)
/* 59 */ _CFFI_OP(_CFFI_OP_ENUM, 0), // BufReq_ReturnType
/* 60 */ _CFFI_OP(_CFFI_OP_ENUM, 1), // CanTp_AddressingFormatType
/* 61 */ _CFFI_OP(_CFFI_OP_ENUM, 2), // CanTp_ChannelMode
/* 62 */ _CFFI_OP(_CFFI_OP_POINTER, 63), // CanTp_ChannelType const *
/* 63 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 1), // CanTp_ChannelType
/* 64 */ _CFFI_OP(_CFFI_OP_ENUM, 3), // CanTp_ComTypeType
/* 65 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 2), // CanTp_ConfigType
/* 66 */ _CFFI_OP(_CFFI_OP_POINTER, 67), // CanTp_NAeType const *
/* 67 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 3), // CanTp_NAeType
/* 68 */ _CFFI_OP(_CFFI_OP_POINTER, 69), // CanTp_NSaType const *
/* 69 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 4), // CanTp_NSaType
/* 70 */ _CFFI_OP(_CFFI_OP_POINTER, 71), // CanTp_NTaType const *
/* 71 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 5), // CanTp_NTaType
/* 72 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 6), // CanTp_RxFcNPduType
/* 73 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 7), // CanTp_RxNPduType
/* 74 */ _CFFI_OP(_CFFI_OP_POINTER, 75), // CanTp_RxNSduType const *
/* 75 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 8), // CanTp_RxNSduType
/* 76 */ _CFFI_OP(_CFFI_OP_ENUM, 4), // CanTp_StateType
/* 77 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 9), // CanTp_TxFcNPduType
/* 78 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 10), // CanTp_TxNPduType
/* 79 */ _CFFI_OP(_CFFI_OP_POINTER, 80), // CanTp_TxNSduType const *
/* 80 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 11), // CanTp_TxNSduType
/* 81 */ _CFFI_OP(_CFFI_OP_ENUM, 5), // IcomSwitch_ErrorType
/* 82 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 12), // PduInfoType
/* 83 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 13), // RetryInfoType
/* 84 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 14), // Std_VersionInfoType
/* 85 */ _CFFI_OP(_CFFI_OP_ENUM, 7), // TpDataStateType
/* 86 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 13), // float
/* 87 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7), // int
/* 88 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 5), // short
/* 89 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 3), // signed char
/* 90 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 0), // struct $1
/* 91 */ _CFFI_OP(_CFFI_OP_POINTER, 36), // unsigned char *
/* 92 */ _CFFI_OP(_CFFI_OP_POINTER, 20), // unsigned int(*)(unsigned short, PduInfoType const *)
/* 93 */ _CFFI_OP(_CFFI_OP_POINTER, 34), // unsigned int(*)(unsigned short, unsigned char, unsigned char, unsigned char)
/* 94 */ _CFFI_OP(_CFFI_OP_POINTER, 50), // void(*)(unsigned short, unsigned int)
/* 95 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 0), // void
};

static int _cffi_const_BUFREQ_OK(unsigned long long *o)
{
  int n = (BUFREQ_OK) <= 0;
  *o = (unsigned long long)((BUFREQ_OK) | 0);  /* check that BUFREQ_OK is an integer */
  return n;
}

static int _cffi_const_BUFREQ_E_NOT_OK(unsigned long long *o)
{
  int n = (BUFREQ_E_NOT_OK) <= 0;
  *o = (unsigned long long)((BUFREQ_E_NOT_OK) | 0);  /* check that BUFREQ_E_NOT_OK is an integer */
  return n;
}

static int _cffi_const_BUFREQ_E_BUSY(unsigned long long *o)
{
  int n = (BUFREQ_E_BUSY) <= 0;
  *o = (unsigned long long)((BUFREQ_E_BUSY) | 0);  /* check that BUFREQ_E_BUSY is an integer */
  return n;
}

static int _cffi_const_BUFREQ_E_OVFL(unsigned long long *o)
{
  int n = (BUFREQ_E_OVFL) <= 0;
  *o = (unsigned long long)((BUFREQ_E_OVFL) | 0);  /* check that BUFREQ_E_OVFL is an integer */
  return n;
}

static int _cffi_const_CANTP_EXTENDED(unsigned long long *o)
{
  int n = (CANTP_EXTENDED) <= 0;
  *o = (unsigned long long)((CANTP_EXTENDED) | 0);  /* check that CANTP_EXTENDED is an integer */
  return n;
}

static int _cffi_const_CANTP_MIXED(unsigned long long *o)
{
  int n = (CANTP_MIXED) <= 0;
  *o = (unsigned long long)((CANTP_MIXED) | 0);  /* check that CANTP_MIXED is an integer */
  return n;
}

static int _cffi_const_CANTP_MIXED29BIT(unsigned long long *o)
{
  int n = (CANTP_MIXED29BIT) <= 0;
  *o = (unsigned long long)((CANTP_MIXED29BIT) | 0);  /* check that CANTP_MIXED29BIT is an integer */
  return n;
}

static int _cffi_const_CANTP_NORMALFIXED(unsigned long long *o)
{
  int n = (CANTP_NORMALFIXED) <= 0;
  *o = (unsigned long long)((CANTP_NORMALFIXED) | 0);  /* check that CANTP_NORMALFIXED is an integer */
  return n;
}

static int _cffi_const_CANTP_STANDARD(unsigned long long *o)
{
  int n = (CANTP_STANDARD) <= 0;
  *o = (unsigned long long)((CANTP_STANDARD) | 0);  /* check that CANTP_STANDARD is an integer */
  return n;
}

static int _cffi_const_CANTP_MODE_FULL_DUPLEX(unsigned long long *o)
{
  int n = (CANTP_MODE_FULL_DUPLEX) <= 0;
  *o = (unsigned long long)((CANTP_MODE_FULL_DUPLEX) | 0);  /* check that CANTP_MODE_FULL_DUPLEX is an integer */
  return n;
}

static int _cffi_const_CANTP_MODE_HALF_DUPLEX(unsigned long long *o)
{
  int n = (CANTP_MODE_HALF_DUPLEX) <= 0;
  *o = (unsigned long long)((CANTP_MODE_HALF_DUPLEX) | 0);  /* check that CANTP_MODE_HALF_DUPLEX is an integer */
  return n;
}

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_CanTp_ChannelType(CanTp_ChannelType *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  /* cannot generate 'struct $1' in field 'nSdu': unknown type name */
  { CanTp_ChannelMode const *tmp = &p->channelMode; (void)tmp; }
}
struct _cffi_align_typedef_CanTp_ChannelType { char x; CanTp_ChannelType y; };

static int _cffi_const_CANTP_FUNCTIONAL(unsigned long long *o)
{
  int n = (CANTP_FUNCTIONAL) <= 0;
  *o = (unsigned long long)((CANTP_FUNCTIONAL) | 0);  /* check that CANTP_FUNCTIONAL is an integer */
  return n;
}

static int _cffi_const_CANTP_PHYSICAL(unsigned long long *o)
{
  int n = (CANTP_PHYSICAL) <= 0;
  *o = (unsigned long long)((CANTP_PHYSICAL) | 0);  /* check that CANTP_PHYSICAL is an integer */
  return n;
}

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_CanTp_ConfigType(CanTp_ConfigType *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->mainFunctionPeriod) | 0);  /* check that 'CanTp_ConfigType.mainFunctionPeriod' is an integer */
  (void)((p->maxChannelCnt) | 0);  /* check that 'CanTp_ConfigType.maxChannelCnt' is an integer */
  { CanTp_ChannelType const * *tmp = &p->pChannel; (void)tmp; }
  (void)((p->paddingByte) | 0);  /* check that 'CanTp_ConfigType.paddingByte' is an integer */
}
struct _cffi_align_typedef_CanTp_ConfigType { char x; CanTp_ConfigType y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_CanTp_NAeType(CanTp_NAeType *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->nAe) | 0);  /* check that 'CanTp_NAeType.nAe' is an integer */
}
struct _cffi_align_typedef_CanTp_NAeType { char x; CanTp_NAeType y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_CanTp_NSaType(CanTp_NSaType *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->nSa) | 0);  /* check that 'CanTp_NSaType.nSa' is an integer */
}
struct _cffi_align_typedef_CanTp_NSaType { char x; CanTp_NSaType y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_CanTp_NTaType(CanTp_NTaType *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->nTa) | 0);  /* check that 'CanTp_NTaType.nTa' is an integer */
}
struct _cffi_align_typedef_CanTp_NTaType { char x; CanTp_NTaType y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_CanTp_RxFcNPduType(CanTp_RxFcNPduType *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->rxFcNPduRef) | 0);  /* check that 'CanTp_RxFcNPduType.rxFcNPduRef' is an integer */
  (void)((p->rxFcNPduId) | 0);  /* check that 'CanTp_RxFcNPduType.rxFcNPduId' is an integer */
}
struct _cffi_align_typedef_CanTp_RxFcNPduType { char x; CanTp_RxFcNPduType y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_CanTp_RxNPduType(CanTp_RxNPduType *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->id) | 0);  /* check that 'CanTp_RxNPduType.id' is an integer */
  (void)((p->rxNPduId) | 0);  /* check that 'CanTp_RxNPduType.rxNPduId' is an integer */
}
struct _cffi_align_typedef_CanTp_RxNPduType { char x; CanTp_RxNPduType y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_CanTp_RxNSduType(CanTp_RxNSduType *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->nSduId) | 0);  /* check that 'CanTp_RxNSduType.nSduId' is an integer */
  { CanTp_NSaType const * *tmp = &p->pNSa; (void)tmp; }
  { CanTp_NTaType const * *tmp = &p->pNTa; (void)tmp; }
  { CanTp_NAeType const * *tmp = &p->pNAe; (void)tmp; }
  (void)((p->bs) | 0);  /* check that 'CanTp_RxNSduType.bs' is an integer */
  (void)((p->nar) | 0);  /* check that 'CanTp_RxNSduType.nar' is an integer */
  (void)((p->nbr) | 0);  /* check that 'CanTp_RxNSduType.nbr' is an integer */
  (void)((p->ncr) | 0);  /* check that 'CanTp_RxNSduType.ncr' is an integer */
  (void)((p->wftMax) | 0);  /* check that 'CanTp_RxNSduType.wftMax' is an integer */
  (void)((p->sTMin) | 0);  /* check that 'CanTp_RxNSduType.sTMin' is an integer */
  { CanTp_AddressingFormatType const *tmp = &p->af; (void)tmp; }
  { CanTp_StateType const *tmp = &p->padding; (void)tmp; }
  { CanTp_ComTypeType const *tmp = &p->taType; (void)tmp; }
  (void)((p->rxNSduRef) | 0);  /* check that 'CanTp_RxNSduType.rxNSduRef' is an integer */
}
struct _cffi_align_typedef_CanTp_RxNSduType { char x; CanTp_RxNSduType y; };

static int _cffi_const_CANTP_OFF(unsigned long long *o)
{
  int n = (CANTP_OFF) <= 0;
  *o = (unsigned long long)((CANTP_OFF) | 0);  /* check that CANTP_OFF is an integer */
  return n;
}

static int _cffi_const_CANTP_ON(unsigned long long *o)
{
  int n = (CANTP_ON) <= 0;
  *o = (unsigned long long)((CANTP_ON) | 0);  /* check that CANTP_ON is an integer */
  return n;
}

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_CanTp_TxFcNPduType(CanTp_TxFcNPduType *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->fcNPduRef) | 0);  /* check that 'CanTp_TxFcNPduType.fcNPduRef' is an integer */
  (void)((p->fcNPduId) | 0);  /* check that 'CanTp_TxFcNPduType.fcNPduId' is an integer */
}
struct _cffi_align_typedef_CanTp_TxFcNPduType { char x; CanTp_TxFcNPduType y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_CanTp_TxNPduType(CanTp_TxNPduType *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->pduRef) | 0);  /* check that 'CanTp_TxNPduType.pduRef' is an integer */
  (void)((p->pduConfirmationPduId) | 0);  /* check that 'CanTp_TxNPduType.pduConfirmationPduId' is an integer */
}
struct _cffi_align_typedef_CanTp_TxNPduType { char x; CanTp_TxNPduType y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_CanTp_TxNSduType(CanTp_TxNSduType *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->nSduId) | 0);  /* check that 'CanTp_TxNSduType.nSduId' is an integer */
  { CanTp_NSaType const * *tmp = &p->pNSa; (void)tmp; }
  { CanTp_NTaType const * *tmp = &p->pNTa; (void)tmp; }
  { CanTp_NAeType const * *tmp = &p->pNAe; (void)tmp; }
  (void)((p->nas) | 0);  /* check that 'CanTp_TxNSduType.nas' is an integer */
  (void)((p->nbs) | 0);  /* check that 'CanTp_TxNSduType.nbs' is an integer */
  (void)((p->ncs) | 0);  /* check that 'CanTp_TxNSduType.ncs' is an integer */
  (void)((p->tc) | 0);  /* check that 'CanTp_TxNSduType.tc' is an integer */
  { CanTp_AddressingFormatType const *tmp = &p->af; (void)tmp; }
  { CanTp_StateType const *tmp = &p->padding; (void)tmp; }
  { CanTp_ComTypeType const *tmp = &p->taType; (void)tmp; }
  (void)((p->txNSduRef) | 0);  /* check that 'CanTp_TxNSduType.txNSduRef' is an integer */
}
struct _cffi_align_typedef_CanTp_TxNSduType { char x; CanTp_TxNSduType y; };

static int _cffi_const_ICOM_SWITCH_E_OK(unsigned long long *o)
{
  int n = (ICOM_SWITCH_E_OK) <= 0;
  *o = (unsigned long long)((ICOM_SWITCH_E_OK) | 0);  /* check that ICOM_SWITCH_E_OK is an integer */
  return n;
}

static int _cffi_const_ICOM_SWITCH_E_FAILED(unsigned long long *o)
{
  int n = (ICOM_SWITCH_E_FAILED) <= 0;
  *o = (unsigned long long)((ICOM_SWITCH_E_FAILED) | 0);  /* check that ICOM_SWITCH_E_FAILED is an integer */
  return n;
}

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_PduInfoType(PduInfoType *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { unsigned char * *tmp = &p->SduDataPtr; (void)tmp; }
  { unsigned char * *tmp = &p->MetaDataPtr; (void)tmp; }
  (void)((p->SduLength) | 0);  /* check that 'PduInfoType.SduLength' is an integer */
}
struct _cffi_align_typedef_PduInfoType { char x; PduInfoType y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_RetryInfoType(RetryInfoType *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { TpDataStateType *tmp = &p->TpDataState; (void)tmp; }
  (void)((p->TxTpDataCnt) | 0);  /* check that 'RetryInfoType.TxTpDataCnt' is an integer */
}
struct _cffi_align_typedef_RetryInfoType { char x; RetryInfoType y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_Std_VersionInfoType(Std_VersionInfoType *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->vendorID) | 0);  /* check that 'Std_VersionInfoType.vendorID' is an integer */
  (void)((p->moduleID) | 0);  /* check that 'Std_VersionInfoType.moduleID' is an integer */
  (void)((p->sw_major_version) | 0);  /* check that 'Std_VersionInfoType.sw_major_version' is an integer */
  (void)((p->sw_minor_version) | 0);  /* check that 'Std_VersionInfoType.sw_minor_version' is an integer */
  (void)((p->sw_patch_version) | 0);  /* check that 'Std_VersionInfoType.sw_patch_version' is an integer */
}
struct _cffi_align_typedef_Std_VersionInfoType { char x; Std_VersionInfoType y; };

static int _cffi_const_TP_STMIN(unsigned long long *o)
{
  int n = (TP_STMIN) <= 0;
  *o = (unsigned long long)((TP_STMIN) | 0);  /* check that TP_STMIN is an integer */
  return n;
}

static int _cffi_const_TP_BS(unsigned long long *o)
{
  int n = (TP_BS) <= 0;
  *o = (unsigned long long)((TP_BS) | 0);  /* check that TP_BS is an integer */
  return n;
}

static int _cffi_const_TP_BC(unsigned long long *o)
{
  int n = (TP_BC) <= 0;
  *o = (unsigned long long)((TP_BC) | 0);  /* check that TP_BC is an integer */
  return n;
}

static int _cffi_const_TP_DATACONF(unsigned long long *o)
{
  int n = (TP_DATACONF) <= 0;
  *o = (unsigned long long)((TP_DATACONF) | 0);  /* check that TP_DATACONF is an integer */
  return n;
}

static int _cffi_const_TP_DATARETRY(unsigned long long *o)
{
  int n = (TP_DATARETRY) <= 0;
  *o = (unsigned long long)((TP_DATARETRY) | 0);  /* check that TP_DATARETRY is an integer */
  return n;
}

static int _cffi_const_TP_CONFPENDING(unsigned long long *o)
{
  int n = (TP_CONFPENDING) <= 0;
  *o = (unsigned long long)((TP_CONFPENDING) | 0);  /* check that TP_CONFPENDING is an integer */
  return n;
}

static struct _cffi_externpy_s _cffi_externpy__CanIf_Transmit =
  { "_cffi_can_tp.CanIf_Transmit", (int)sizeof(unsigned int) };

unsigned int CanIf_Transmit(unsigned short a0, PduInfoType const * a1)
{
  char a[16];
  char *p = a;
  *(unsigned short *)(p + 0) = a0;
  *(PduInfoType const * *)(p + 8) = a1;
  _cffi_call_python(&_cffi_externpy__CanIf_Transmit, p);
  return *(unsigned int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__Det_ReportError =
  { "_cffi_can_tp.Det_ReportError", (int)sizeof(unsigned int) };

unsigned int Det_ReportError(unsigned short a0, unsigned char a1, unsigned char a2, unsigned char a3)
{
  char a[32];
  char *p = a;
  *(unsigned short *)(p + 0) = a0;
  *(unsigned char *)(p + 8) = a1;
  *(unsigned char *)(p + 16) = a2;
  *(unsigned char *)(p + 24) = a3;
  _cffi_call_python(&_cffi_externpy__Det_ReportError, p);
  return *(unsigned int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__Det_ReportRuntimeError =
  { "_cffi_can_tp.Det_ReportRuntimeError", (int)sizeof(unsigned int) };

unsigned int Det_ReportRuntimeError(unsigned short a0, unsigned char a1, unsigned char a2, unsigned char a3)
{
  char a[32];
  char *p = a;
  *(unsigned short *)(p + 0) = a0;
  *(unsigned char *)(p + 8) = a1;
  *(unsigned char *)(p + 16) = a2;
  *(unsigned char *)(p + 24) = a3;
  _cffi_call_python(&_cffi_externpy__Det_ReportRuntimeError, p);
  return *(unsigned int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__Det_ReportTransientFault =
  { "_cffi_can_tp.Det_ReportTransientFault", (int)sizeof(unsigned int) };

unsigned int Det_ReportTransientFault(unsigned short a0, unsigned char a1, unsigned char a2, unsigned char a3)
{
  char a[32];
  char *p = a;
  *(unsigned short *)(p + 0) = a0;
  *(unsigned char *)(p + 8) = a1;
  *(unsigned char *)(p + 16) = a2;
  *(unsigned char *)(p + 24) = a3;
  _cffi_call_python(&_cffi_externpy__Det_ReportTransientFault, p);
  return *(unsigned int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__PduR_CanTpCopyRxData =
  { "_cffi_can_tp.PduR_CanTpCopyRxData", (int)sizeof(BufReq_ReturnType) };

BufReq_ReturnType PduR_CanTpCopyRxData(unsigned short a0, PduInfoType const * a1, unsigned int * a2)
{
  char a[24];
  char *p = a;
  *(unsigned short *)(p + 0) = a0;
  *(PduInfoType const * *)(p + 8) = a1;
  *(unsigned int * *)(p + 16) = a2;
  _cffi_call_python(&_cffi_externpy__PduR_CanTpCopyRxData, p);
  return *(BufReq_ReturnType *)p;
}

static struct _cffi_externpy_s _cffi_externpy__PduR_CanTpCopyTxData =
  { "_cffi_can_tp.PduR_CanTpCopyTxData", (int)sizeof(BufReq_ReturnType) };

BufReq_ReturnType PduR_CanTpCopyTxData(unsigned short a0, PduInfoType const * a1, RetryInfoType const * a2, unsigned int * a3)
{
  char a[32];
  char *p = a;
  *(unsigned short *)(p + 0) = a0;
  *(PduInfoType const * *)(p + 8) = a1;
  *(RetryInfoType const * *)(p + 16) = a2;
  *(unsigned int * *)(p + 24) = a3;
  _cffi_call_python(&_cffi_externpy__PduR_CanTpCopyTxData, p);
  return *(BufReq_ReturnType *)p;
}

static struct _cffi_externpy_s _cffi_externpy__PduR_CanTpRxIndication =
  { "_cffi_can_tp.PduR_CanTpRxIndication", 0 };

void PduR_CanTpRxIndication(unsigned short a0, unsigned int a1)
{
  char a[16];
  char *p = a;
  *(unsigned short *)(p + 0) = a0;
  *(unsigned int *)(p + 8) = a1;
  _cffi_call_python(&_cffi_externpy__PduR_CanTpRxIndication, p);
}

static struct _cffi_externpy_s _cffi_externpy__PduR_CanTpStartOfReception =
  { "_cffi_can_tp.PduR_CanTpStartOfReception", (int)sizeof(BufReq_ReturnType) };

BufReq_ReturnType PduR_CanTpStartOfReception(unsigned short a0, PduInfoType const * a1, unsigned int a2, unsigned int * a3)
{
  char a[32];
  char *p = a;
  *(unsigned short *)(p + 0) = a0;
  *(PduInfoType const * *)(p + 8) = a1;
  *(unsigned int *)(p + 16) = a2;
  *(unsigned int * *)(p + 24) = a3;
  _cffi_call_python(&_cffi_externpy__PduR_CanTpStartOfReception, p);
  return *(BufReq_ReturnType *)p;
}

static struct _cffi_externpy_s _cffi_externpy__PduR_CanTpTxConfirmation =
  { "_cffi_can_tp.PduR_CanTpTxConfirmation", 0 };

void PduR_CanTpTxConfirmation(unsigned short a0, unsigned int a1)
{
  char a[16];
  char *p = a;
  *(unsigned short *)(p + 0) = a0;
  *(unsigned int *)(p + 8) = a1;
  _cffi_call_python(&_cffi_externpy__PduR_CanTpTxConfirmation, p);
}

static unsigned int _cffi_d_CanTp_CancelReceive(unsigned short x0)
{
  return CanTp_CancelReceive(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CanTp_CancelReceive(PyObject *self, PyObject *arg0)
{
  unsigned short x0;
  unsigned int result;

  x0 = _cffi_to_c_int(arg0, unsigned short);
  if (x0 == (unsigned short)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CanTp_CancelReceive(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned int);
}
#else
#  define _cffi_f_CanTp_CancelReceive _cffi_d_CanTp_CancelReceive
#endif

static unsigned int _cffi_d_CanTp_CancelTransmit(unsigned short x0)
{
  return CanTp_CancelTransmit(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CanTp_CancelTransmit(PyObject *self, PyObject *arg0)
{
  unsigned short x0;
  unsigned int result;

  x0 = _cffi_to_c_int(arg0, unsigned short);
  if (x0 == (unsigned short)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CanTp_CancelTransmit(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned int);
}
#else
#  define _cffi_f_CanTp_CancelTransmit _cffi_d_CanTp_CancelTransmit
#endif

static unsigned int _cffi_d_CanTp_ChangeParameter(unsigned short x0, TPParameterType x1, unsigned short x2)
{
  return CanTp_ChangeParameter(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CanTp_ChangeParameter(PyObject *self, PyObject *args)
{
  unsigned short x0;
  TPParameterType x1;
  unsigned short x2;
  unsigned int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "CanTp_ChangeParameter", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  x0 = _cffi_to_c_int(arg0, unsigned short);
  if (x0 == (unsigned short)-1 && PyErr_Occurred())
    return NULL;

  if (_cffi_to_c((char *)&x1, _cffi_type(26), arg1) < 0)
    return NULL;

  x2 = _cffi_to_c_int(arg2, unsigned short);
  if (x2 == (unsigned short)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CanTp_ChangeParameter(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned int);
}
#else
#  define _cffi_f_CanTp_ChangeParameter _cffi_d_CanTp_ChangeParameter
#endif

static void _cffi_d_CanTp_GetVersionInfo(Std_VersionInfoType * x0)
{
  CanTp_GetVersionInfo(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CanTp_GetVersionInfo(PyObject *self, PyObject *arg0)
{
  Std_VersionInfoType * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(44), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (Std_VersionInfoType *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(44), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CanTp_GetVersionInfo(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CanTp_GetVersionInfo _cffi_d_CanTp_GetVersionInfo
#endif

static void _cffi_d_CanTp_Init(CanTp_ConfigType const * x0)
{
  CanTp_Init(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CanTp_Init(PyObject *self, PyObject *arg0)
{
  CanTp_ConfigType const * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(41), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (CanTp_ConfigType const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(41), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CanTp_Init(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CanTp_Init _cffi_d_CanTp_Init
#endif

static void _cffi_d_CanTp_MainFunction(void)
{
  CanTp_MainFunction();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CanTp_MainFunction(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CanTp_MainFunction(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CanTp_MainFunction _cffi_d_CanTp_MainFunction
#endif

static unsigned int _cffi_d_CanTp_ReadParameter(unsigned short x0, TPParameterType x1, unsigned short * x2)
{
  return CanTp_ReadParameter(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CanTp_ReadParameter(PyObject *self, PyObject *args)
{
  unsigned short x0;
  TPParameterType x1;
  unsigned short * x2;
  Py_ssize_t datasize;
  unsigned int result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "CanTp_ReadParameter", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  x0 = _cffi_to_c_int(arg0, unsigned short);
  if (x0 == (unsigned short)-1 && PyErr_Occurred())
    return NULL;

  if (_cffi_to_c((char *)&x1, _cffi_type(26), arg1) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (unsigned short *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(27), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CanTp_ReadParameter(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned int);
}
#else
#  define _cffi_f_CanTp_ReadParameter _cffi_d_CanTp_ReadParameter
#endif

static void _cffi_d_CanTp_RxIndication(unsigned short x0, PduInfoType const * x1)
{
  CanTp_RxIndication(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CanTp_RxIndication(PyObject *self, PyObject *args)
{
  unsigned short x0;
  PduInfoType const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "CanTp_RxIndication", 2, 2, &arg0, &arg1))
    return NULL;

  x0 = _cffi_to_c_int(arg0, unsigned short);
  if (x0 == (unsigned short)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (PduInfoType const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(2), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CanTp_RxIndication(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CanTp_RxIndication _cffi_d_CanTp_RxIndication
#endif

static void _cffi_d_CanTp_Shutdown(void)
{
  CanTp_Shutdown();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CanTp_Shutdown(PyObject *self, PyObject *noarg)
{

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CanTp_Shutdown(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CanTp_Shutdown _cffi_d_CanTp_Shutdown
#endif

static unsigned int _cffi_d_CanTp_Transmit(unsigned short x0, PduInfoType const * x1)
{
  return CanTp_Transmit(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CanTp_Transmit(PyObject *self, PyObject *args)
{
  unsigned short x0;
  PduInfoType const * x1;
  Py_ssize_t datasize;
  unsigned int result;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "CanTp_Transmit", 2, 2, &arg0, &arg1))
    return NULL;

  x0 = _cffi_to_c_int(arg0, unsigned short);
  if (x0 == (unsigned short)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(2), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (PduInfoType const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(2), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = CanTp_Transmit(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, unsigned int);
}
#else
#  define _cffi_f_CanTp_Transmit _cffi_d_CanTp_Transmit
#endif

static void _cffi_d_CanTp_TxConfirmation(unsigned short x0, unsigned int x1)
{
  CanTp_TxConfirmation(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_CanTp_TxConfirmation(PyObject *self, PyObject *args)
{
  unsigned short x0;
  unsigned int x1;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "CanTp_TxConfirmation", 2, 2, &arg0, &arg1))
    return NULL;

  x0 = _cffi_to_c_int(arg0, unsigned short);
  if (x0 == (unsigned short)-1 && PyErr_Occurred())
    return NULL;

  x1 = _cffi_to_c_int(arg1, unsigned int);
  if (x1 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { CanTp_TxConfirmation(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_CanTp_TxConfirmation _cffi_d_CanTp_TxConfirmation
#endif

static CanTp_StateType *_cffi_var_CanTp_State(void)
{
  return &(CanTp_State);
}

static const struct _cffi_global_s _cffi_globals[] = {
  { "BUFREQ_E_BUSY", (void *)_cffi_const_BUFREQ_E_BUSY, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "BUFREQ_E_NOT_OK", (void *)_cffi_const_BUFREQ_E_NOT_OK, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "BUFREQ_E_OVFL", (void *)_cffi_const_BUFREQ_E_OVFL, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "BUFREQ_OK", (void *)_cffi_const_BUFREQ_OK, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "CANTP_EXTENDED", (void *)_cffi_const_CANTP_EXTENDED, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "CANTP_FUNCTIONAL", (void *)_cffi_const_CANTP_FUNCTIONAL, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "CANTP_MIXED", (void *)_cffi_const_CANTP_MIXED, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "CANTP_MIXED29BIT", (void *)_cffi_const_CANTP_MIXED29BIT, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "CANTP_MODE_FULL_DUPLEX", (void *)_cffi_const_CANTP_MODE_FULL_DUPLEX, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "CANTP_MODE_HALF_DUPLEX", (void *)_cffi_const_CANTP_MODE_HALF_DUPLEX, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "CANTP_NORMALFIXED", (void *)_cffi_const_CANTP_NORMALFIXED, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "CANTP_OFF", (void *)_cffi_const_CANTP_OFF, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "CANTP_ON", (void *)_cffi_const_CANTP_ON, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "CANTP_PHYSICAL", (void *)_cffi_const_CANTP_PHYSICAL, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "CANTP_STANDARD", (void *)_cffi_const_CANTP_STANDARD, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "CanIf_Transmit", (void *)&_cffi_externpy__CanIf_Transmit, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 92), (void *)CanIf_Transmit },
  { "CanTp_CancelReceive", (void *)_cffi_f_CanTp_CancelReceive, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 17), (void *)_cffi_d_CanTp_CancelReceive },
  { "CanTp_CancelTransmit", (void *)_cffi_f_CanTp_CancelTransmit, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 17), (void *)_cffi_d_CanTp_CancelTransmit },
  { "CanTp_ChangeParameter", (void *)_cffi_f_CanTp_ChangeParameter, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 29), (void *)_cffi_d_CanTp_ChangeParameter },
  { "CanTp_GetVersionInfo", (void *)_cffi_f_CanTp_GetVersionInfo, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 43), (void *)_cffi_d_CanTp_GetVersionInfo },
  { "CanTp_Init", (void *)_cffi_f_CanTp_Init, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 40), (void *)_cffi_d_CanTp_Init },
  { "CanTp_MainFunction", (void *)_cffi_f_CanTp_MainFunction, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 54), (void *)_cffi_d_CanTp_MainFunction },
  { "CanTp_ReadParameter", (void *)_cffi_f_CanTp_ReadParameter, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 24), (void *)_cffi_d_CanTp_ReadParameter },
  { "CanTp_RxIndication", (void *)_cffi_f_CanTp_RxIndication, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 46), (void *)_cffi_d_CanTp_RxIndication },
  { "CanTp_Shutdown", (void *)_cffi_f_CanTp_Shutdown, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 54), (void *)_cffi_d_CanTp_Shutdown },
  { "CanTp_State", (void *)_cffi_var_CanTp_State, _CFFI_OP(_CFFI_OP_GLOBAL_VAR_F, 76), (void *)0 },
  { "CanTp_Transmit", (void *)_cffi_f_CanTp_Transmit, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 20), (void *)_cffi_d_CanTp_Transmit },
  { "CanTp_TxConfirmation", (void *)_cffi_f_CanTp_TxConfirmation, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 50), (void *)_cffi_d_CanTp_TxConfirmation },
  { "Det_ReportError", (void *)&_cffi_externpy__Det_ReportError, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 93), (void *)Det_ReportError },
  { "Det_ReportRuntimeError", (void *)&_cffi_externpy__Det_ReportRuntimeError, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 93), (void *)Det_ReportRuntimeError },
  { "Det_ReportTransientFault", (void *)&_cffi_externpy__Det_ReportTransientFault, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 93), (void *)Det_ReportTransientFault },
  { "ICOM_SWITCH_E_FAILED", (void *)_cffi_const_ICOM_SWITCH_E_FAILED, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "ICOM_SWITCH_E_OK", (void *)_cffi_const_ICOM_SWITCH_E_OK, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "PduR_CanTpCopyRxData", (void *)&_cffi_externpy__PduR_CanTpCopyRxData, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 57), (void *)PduR_CanTpCopyRxData },
  { "PduR_CanTpCopyTxData", (void *)&_cffi_externpy__PduR_CanTpCopyTxData, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 56), (void *)PduR_CanTpCopyTxData },
  { "PduR_CanTpRxIndication", (void *)&_cffi_externpy__PduR_CanTpRxIndication, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 94), (void *)PduR_CanTpRxIndication },
  { "PduR_CanTpStartOfReception", (void *)&_cffi_externpy__PduR_CanTpStartOfReception, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 58), (void *)PduR_CanTpStartOfReception },
  { "PduR_CanTpTxConfirmation", (void *)&_cffi_externpy__PduR_CanTpTxConfirmation, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 94), (void *)PduR_CanTpTxConfirmation },
  { "TP_BC", (void *)_cffi_const_TP_BC, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TP_BS", (void *)_cffi_const_TP_BS, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TP_CONFPENDING", (void *)_cffi_const_TP_CONFPENDING, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TP_DATACONF", (void *)_cffi_const_TP_DATACONF, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TP_DATARETRY", (void *)_cffi_const_TP_DATARETRY, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TP_STMIN", (void *)_cffi_const_TP_STMIN, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
};

static const struct _cffi_field_s _cffi_fields[] = {
  { "nSdu", offsetof(CanTp_ChannelType, nSdu),
            sizeof(((CanTp_ChannelType *)0)->nSdu),
            _CFFI_OP(_CFFI_OP_NOOP, 90) },
  { "channelMode", offsetof(CanTp_ChannelType, channelMode),
                   sizeof(((CanTp_ChannelType *)0)->channelMode),
                   _CFFI_OP(_CFFI_OP_NOOP, 61) },
  { "mainFunctionPeriod", offsetof(CanTp_ConfigType, mainFunctionPeriod),
                          sizeof(((CanTp_ConfigType *)0)->mainFunctionPeriod),
                          _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "maxChannelCnt", offsetof(CanTp_ConfigType, maxChannelCnt),
                     sizeof(((CanTp_ConfigType *)0)->maxChannelCnt),
                     _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "pChannel", offsetof(CanTp_ConfigType, pChannel),
                sizeof(((CanTp_ConfigType *)0)->pChannel),
                _CFFI_OP(_CFFI_OP_NOOP, 62) },
  { "paddingByte", offsetof(CanTp_ConfigType, paddingByte),
                   sizeof(((CanTp_ConfigType *)0)->paddingByte),
                   _CFFI_OP(_CFFI_OP_NOOP, 36) },
  { "nAe", offsetof(CanTp_NAeType, nAe),
           sizeof(((CanTp_NAeType *)0)->nAe),
           _CFFI_OP(_CFFI_OP_NOOP, 36) },
  { "nSa", offsetof(CanTp_NSaType, nSa),
           sizeof(((CanTp_NSaType *)0)->nSa),
           _CFFI_OP(_CFFI_OP_NOOP, 36) },
  { "nTa", offsetof(CanTp_NTaType, nTa),
           sizeof(((CanTp_NTaType *)0)->nTa),
           _CFFI_OP(_CFFI_OP_NOOP, 36) },
  { "rxFcNPduRef", offsetof(CanTp_RxFcNPduType, rxFcNPduRef),
                   sizeof(((CanTp_RxFcNPduType *)0)->rxFcNPduRef),
                   _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "rxFcNPduId", offsetof(CanTp_RxFcNPduType, rxFcNPduId),
                  sizeof(((CanTp_RxFcNPduType *)0)->rxFcNPduId),
                  _CFFI_OP(_CFFI_OP_NOOP, 1) },
  { "id", offsetof(CanTp_RxNPduType, id),
          sizeof(((CanTp_RxNPduType *)0)->id),
          _CFFI_OP(_CFFI_OP_NOOP, 1) },
  { "rxNPduId", offsetof(CanTp_RxNPduType, rxNPduId),
                sizeof(((CanTp_RxNPduType *)0)->rxNPduId),
                _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "nSduId", offsetof(CanTp_RxNSduType, nSduId),
              sizeof(((CanTp_RxNSduType *)0)->nSduId),
              _CFFI_OP(_CFFI_OP_NOOP, 1) },
  { "pNSa", offsetof(CanTp_RxNSduType, pNSa),
            sizeof(((CanTp_RxNSduType *)0)->pNSa),
            _CFFI_OP(_CFFI_OP_NOOP, 68) },
  { "pNTa", offsetof(CanTp_RxNSduType, pNTa),
            sizeof(((CanTp_RxNSduType *)0)->pNTa),
            _CFFI_OP(_CFFI_OP_NOOP, 70) },
  { "pNAe", offsetof(CanTp_RxNSduType, pNAe),
            sizeof(((CanTp_RxNSduType *)0)->pNAe),
            _CFFI_OP(_CFFI_OP_NOOP, 66) },
  { "bs", offsetof(CanTp_RxNSduType, bs),
          sizeof(((CanTp_RxNSduType *)0)->bs),
          _CFFI_OP(_CFFI_OP_NOOP, 36) },
  { "nar", offsetof(CanTp_RxNSduType, nar),
           sizeof(((CanTp_RxNSduType *)0)->nar),
           _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "nbr", offsetof(CanTp_RxNSduType, nbr),
           sizeof(((CanTp_RxNSduType *)0)->nbr),
           _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "ncr", offsetof(CanTp_RxNSduType, ncr),
           sizeof(((CanTp_RxNSduType *)0)->ncr),
           _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "wftMax", offsetof(CanTp_RxNSduType, wftMax),
              sizeof(((CanTp_RxNSduType *)0)->wftMax),
              _CFFI_OP(_CFFI_OP_NOOP, 1) },
  { "sTMin", offsetof(CanTp_RxNSduType, sTMin),
             sizeof(((CanTp_RxNSduType *)0)->sTMin),
             _CFFI_OP(_CFFI_OP_NOOP, 1) },
  { "af", offsetof(CanTp_RxNSduType, af),
          sizeof(((CanTp_RxNSduType *)0)->af),
          _CFFI_OP(_CFFI_OP_NOOP, 60) },
  { "padding", offsetof(CanTp_RxNSduType, padding),
               sizeof(((CanTp_RxNSduType *)0)->padding),
               _CFFI_OP(_CFFI_OP_NOOP, 76) },
  { "taType", offsetof(CanTp_RxNSduType, taType),
              sizeof(((CanTp_RxNSduType *)0)->taType),
              _CFFI_OP(_CFFI_OP_NOOP, 64) },
  { "rxNSduRef", offsetof(CanTp_RxNSduType, rxNSduRef),
                 sizeof(((CanTp_RxNSduType *)0)->rxNSduRef),
                 _CFFI_OP(_CFFI_OP_NOOP, 1) },
  { "fcNPduRef", offsetof(CanTp_TxFcNPduType, fcNPduRef),
                 sizeof(((CanTp_TxFcNPduType *)0)->fcNPduRef),
                 _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "fcNPduId", offsetof(CanTp_TxFcNPduType, fcNPduId),
                sizeof(((CanTp_TxFcNPduType *)0)->fcNPduId),
                _CFFI_OP(_CFFI_OP_NOOP, 1) },
  { "pduRef", offsetof(CanTp_TxNPduType, pduRef),
              sizeof(((CanTp_TxNPduType *)0)->pduRef),
              _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "pduConfirmationPduId", offsetof(CanTp_TxNPduType, pduConfirmationPduId),
                            sizeof(((CanTp_TxNPduType *)0)->pduConfirmationPduId),
                            _CFFI_OP(_CFFI_OP_NOOP, 1) },
  { "nSduId", offsetof(CanTp_TxNSduType, nSduId),
              sizeof(((CanTp_TxNSduType *)0)->nSduId),
              _CFFI_OP(_CFFI_OP_NOOP, 1) },
  { "pNSa", offsetof(CanTp_TxNSduType, pNSa),
            sizeof(((CanTp_TxNSduType *)0)->pNSa),
            _CFFI_OP(_CFFI_OP_NOOP, 68) },
  { "pNTa", offsetof(CanTp_TxNSduType, pNTa),
            sizeof(((CanTp_TxNSduType *)0)->pNTa),
            _CFFI_OP(_CFFI_OP_NOOP, 70) },
  { "pNAe", offsetof(CanTp_TxNSduType, pNAe),
            sizeof(((CanTp_TxNSduType *)0)->pNAe),
            _CFFI_OP(_CFFI_OP_NOOP, 66) },
  { "nas", offsetof(CanTp_TxNSduType, nas),
           sizeof(((CanTp_TxNSduType *)0)->nas),
           _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "nbs", offsetof(CanTp_TxNSduType, nbs),
           sizeof(((CanTp_TxNSduType *)0)->nbs),
           _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "ncs", offsetof(CanTp_TxNSduType, ncs),
           sizeof(((CanTp_TxNSduType *)0)->ncs),
           _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "tc", offsetof(CanTp_TxNSduType, tc),
          sizeof(((CanTp_TxNSduType *)0)->tc),
          _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "af", offsetof(CanTp_TxNSduType, af),
          sizeof(((CanTp_TxNSduType *)0)->af),
          _CFFI_OP(_CFFI_OP_NOOP, 60) },
  { "padding", offsetof(CanTp_TxNSduType, padding),
               sizeof(((CanTp_TxNSduType *)0)->padding),
               _CFFI_OP(_CFFI_OP_NOOP, 76) },
  { "taType", offsetof(CanTp_TxNSduType, taType),
              sizeof(((CanTp_TxNSduType *)0)->taType),
              _CFFI_OP(_CFFI_OP_NOOP, 64) },
  { "txNSduRef", offsetof(CanTp_TxNSduType, txNSduRef),
                 sizeof(((CanTp_TxNSduType *)0)->txNSduRef),
                 _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "SduDataPtr", offsetof(PduInfoType, SduDataPtr),
                  sizeof(((PduInfoType *)0)->SduDataPtr),
                  _CFFI_OP(_CFFI_OP_NOOP, 91) },
  { "MetaDataPtr", offsetof(PduInfoType, MetaDataPtr),
                   sizeof(((PduInfoType *)0)->MetaDataPtr),
                   _CFFI_OP(_CFFI_OP_NOOP, 91) },
  { "SduLength", offsetof(PduInfoType, SduLength),
                 sizeof(((PduInfoType *)0)->SduLength),
                 _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "TpDataState", offsetof(RetryInfoType, TpDataState),
                   sizeof(((RetryInfoType *)0)->TpDataState),
                   _CFFI_OP(_CFFI_OP_NOOP, 85) },
  { "TxTpDataCnt", offsetof(RetryInfoType, TxTpDataCnt),
                   sizeof(((RetryInfoType *)0)->TxTpDataCnt),
                   _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "vendorID", offsetof(Std_VersionInfoType, vendorID),
                sizeof(((Std_VersionInfoType *)0)->vendorID),
                _CFFI_OP(_CFFI_OP_NOOP, 1) },
  { "moduleID", offsetof(Std_VersionInfoType, moduleID),
                sizeof(((Std_VersionInfoType *)0)->moduleID),
                _CFFI_OP(_CFFI_OP_NOOP, 1) },
  { "sw_major_version", offsetof(Std_VersionInfoType, sw_major_version),
                        sizeof(((Std_VersionInfoType *)0)->sw_major_version),
                        _CFFI_OP(_CFFI_OP_NOOP, 36) },
  { "sw_minor_version", offsetof(Std_VersionInfoType, sw_minor_version),
                        sizeof(((Std_VersionInfoType *)0)->sw_minor_version),
                        _CFFI_OP(_CFFI_OP_NOOP, 36) },
  { "sw_patch_version", offsetof(Std_VersionInfoType, sw_patch_version),
                        sizeof(((Std_VersionInfoType *)0)->sw_patch_version),
                        _CFFI_OP(_CFFI_OP_NOOP, 36) },
  { "rx", (size_t)-1,
          (size_t)-1,
          _CFFI_OP(_CFFI_OP_NOOP, 74) },
  { "rxNSduCnt", (size_t)-1,
                 (size_t)-1,
                 _CFFI_OP(_CFFI_OP_NOOP, 14) },
  { "tx", (size_t)-1,
          (size_t)-1,
          _CFFI_OP(_CFFI_OP_NOOP, 79) },
  { "txNSduCnt", (size_t)-1,
                 (size_t)-1,
                 _CFFI_OP(_CFFI_OP_NOOP, 14) },
};

static const struct _cffi_struct_union_s _cffi_struct_unions[] = {
  { "$1", 90, _CFFI_F_CHECK_FIELDS,
    (size_t)-2, -2, 53, 4 /* unnamed */ },
  { "$CanTp_ChannelType", 63, _CFFI_F_CHECK_FIELDS,
    sizeof(CanTp_ChannelType), offsetof(struct _cffi_align_typedef_CanTp_ChannelType, y), 0, 2 },
  { "$CanTp_ConfigType", 65, _CFFI_F_CHECK_FIELDS,
    sizeof(CanTp_ConfigType), offsetof(struct _cffi_align_typedef_CanTp_ConfigType, y), 2, 4 },
  { "$CanTp_NAeType", 67, _CFFI_F_CHECK_FIELDS,
    sizeof(CanTp_NAeType), offsetof(struct _cffi_align_typedef_CanTp_NAeType, y), 6, 1 },
  { "$CanTp_NSaType", 69, _CFFI_F_CHECK_FIELDS,
    sizeof(CanTp_NSaType), offsetof(struct _cffi_align_typedef_CanTp_NSaType, y), 7, 1 },
  { "$CanTp_NTaType", 71, _CFFI_F_CHECK_FIELDS,
    sizeof(CanTp_NTaType), offsetof(struct _cffi_align_typedef_CanTp_NTaType, y), 8, 1 },
  { "$CanTp_RxFcNPduType", 72, _CFFI_F_CHECK_FIELDS,
    sizeof(CanTp_RxFcNPduType), offsetof(struct _cffi_align_typedef_CanTp_RxFcNPduType, y), 9, 2 },
  { "$CanTp_RxNPduType", 73, _CFFI_F_CHECK_FIELDS,
    sizeof(CanTp_RxNPduType), offsetof(struct _cffi_align_typedef_CanTp_RxNPduType, y), 11, 2 },
  { "$CanTp_RxNSduType", 75, _CFFI_F_CHECK_FIELDS,
    sizeof(CanTp_RxNSduType), offsetof(struct _cffi_align_typedef_CanTp_RxNSduType, y), 13, 14 },
  { "$CanTp_TxFcNPduType", 77, _CFFI_F_CHECK_FIELDS,
    sizeof(CanTp_TxFcNPduType), offsetof(struct _cffi_align_typedef_CanTp_TxFcNPduType, y), 27, 2 },
  { "$CanTp_TxNPduType", 78, _CFFI_F_CHECK_FIELDS,
    sizeof(CanTp_TxNPduType), offsetof(struct _cffi_align_typedef_CanTp_TxNPduType, y), 29, 2 },
  { "$CanTp_TxNSduType", 80, _CFFI_F_CHECK_FIELDS,
    sizeof(CanTp_TxNSduType), offsetof(struct _cffi_align_typedef_CanTp_TxNSduType, y), 31, 12 },
  { "$PduInfoType", 82, _CFFI_F_CHECK_FIELDS,
    sizeof(PduInfoType), offsetof(struct _cffi_align_typedef_PduInfoType, y), 43, 3 },
  { "$RetryInfoType", 83, _CFFI_F_CHECK_FIELDS,
    sizeof(RetryInfoType), offsetof(struct _cffi_align_typedef_RetryInfoType, y), 46, 2 },
  { "$Std_VersionInfoType", 84, _CFFI_F_CHECK_FIELDS,
    sizeof(Std_VersionInfoType), offsetof(struct _cffi_align_typedef_Std_VersionInfoType, y), 48, 5 },
};

static const struct _cffi_enum_s _cffi_enums[] = {
  { "$BufReq_ReturnType", 59, _cffi_prim_int(sizeof(BufReq_ReturnType), ((BufReq_ReturnType)-1) <= 0),
    "BUFREQ_OK,BUFREQ_E_NOT_OK,BUFREQ_E_BUSY,BUFREQ_E_OVFL" },
  { "$CanTp_AddressingFormatType", 60, _cffi_prim_int(sizeof(CanTp_AddressingFormatType), ((CanTp_AddressingFormatType)-1) <= 0),
    "CANTP_EXTENDED,CANTP_MIXED,CANTP_MIXED29BIT,CANTP_NORMALFIXED,CANTP_STANDARD" },
  { "$CanTp_ChannelMode", 61, _cffi_prim_int(sizeof(CanTp_ChannelMode), ((CanTp_ChannelMode)-1) <= 0),
    "CANTP_MODE_FULL_DUPLEX,CANTP_MODE_HALF_DUPLEX" },
  { "$CanTp_ComTypeType", 64, _cffi_prim_int(sizeof(CanTp_ComTypeType), ((CanTp_ComTypeType)-1) <= 0),
    "CANTP_FUNCTIONAL,CANTP_PHYSICAL" },
  { "$CanTp_StateType", 76, _cffi_prim_int(sizeof(CanTp_StateType), ((CanTp_StateType)-1) <= 0),
    "CANTP_OFF,CANTP_ON" },
  { "$IcomSwitch_ErrorType", 81, _cffi_prim_int(sizeof(IcomSwitch_ErrorType), ((IcomSwitch_ErrorType)-1) <= 0),
    "ICOM_SWITCH_E_OK,ICOM_SWITCH_E_FAILED" },
  { "$TPParameterType", 26, _cffi_prim_int(sizeof(TPParameterType), ((TPParameterType)-1) <= 0),
    "TP_STMIN,TP_BS,TP_BC" },
  { "$TpDataStateType", 85, _cffi_prim_int(sizeof(TpDataStateType), ((TpDataStateType)-1) <= 0),
    "TP_DATACONF,TP_DATARETRY,TP_CONFPENDING" },
};

static const struct _cffi_typename_s _cffi_typenames[] = {
  { "BufReq_ReturnType", 59 },
  { "CanTp_AddressingFormatType", 60 },
  { "CanTp_ChannelMode", 61 },
  { "CanTp_ChannelType", 63 },
  { "CanTp_ComTypeType", 64 },
  { "CanTp_ConfigType", 65 },
  { "CanTp_NAeType", 67 },
  { "CanTp_NSaType", 69 },
  { "CanTp_NTaType", 71 },
  { "CanTp_RxFcNPduType", 72 },
  { "CanTp_RxNPduType", 73 },
  { "CanTp_RxNSduType", 75 },
  { "CanTp_RxPaddingActivationType", 76 },
  { "CanTp_StateType", 76 },
  { "CanTp_TxFcNPduType", 77 },
  { "CanTp_TxNPduType", 78 },
  { "CanTp_TxNSduType", 80 },
  { "CanTp_TxPaddingActivationType", 76 },
  { "IcomConfigIdType", 36 },
  { "IcomSwitch_ErrorType", 81 },
  { "NetworkHandleType", 36 },
  { "PduIdType", 1 },
  { "PduInfoType", 82 },
  { "PduLengthType", 14 },
  { "RetryInfoType", 83 },
  { "Std_ReturnType", 14 },
  { "Std_VersionInfoType", 84 },
  { "TPParameterType", 26 },
  { "TpDataStateType", 85 },
  { "boolean", 14 },
  { "ieee_float", 86 },
  { "sint16", 88 },
  { "sint16_least", 87 },
  { "sint32", 87 },
  { "sint32_least", 87 },
  { "sint8", 89 },
  { "sint8_least", 87 },
  { "uint16", 1 },
  { "uint16_least", 14 },
  { "uint32", 14 },
  { "uint32_least", 14 },
  { "uint8", 36 },
  { "uint8_least", 14 },
};

static const struct _cffi_type_context_s _cffi_type_context = {
  _cffi_types,
  _cffi_globals,
  _cffi_fields,
  _cffi_struct_unions,
  _cffi_enums,
  _cffi_typenames,
  44,  /* num_globals */
  15,  /* num_struct_unions */
  8,  /* num_enums */
  43,  /* num_typenames */
  NULL,  /* no includes */
  96,  /* num_types */
  1,  /* flags */
};

#ifdef __GNUC__
#  pragma GCC visibility push(default)  /* for -fvisibility= */
#endif

#ifdef PYPY_VERSION
PyMODINIT_FUNC
_cffi_pypyinit__cffi_can_tp(const void *p[])
{
    if (((intptr_t)p[0]) >= 0x0A03) {
        _cffi_call_python_org = (void(*)(struct _cffi_externpy_s *, char *))p[1];
    }
    p[0] = (const void *)0x2601;
    p[1] = &_cffi_type_context;
#if PY_MAJOR_VERSION >= 3
    return NULL;
#endif
}
#  ifdef _MSC_VER
     PyMODINIT_FUNC
#  if PY_MAJOR_VERSION >= 3
     PyInit__cffi_can_tp(void) { return NULL; }
#  else
     init_cffi_can_tp(void) { }
#  endif
#  endif
#elif PY_MAJOR_VERSION >= 3
PyMODINIT_FUNC
PyInit__cffi_can_tp(void)
{
  return _cffi_init("_cffi_can_tp", 0x2601, &_cffi_type_context);
}
#else
PyMODINIT_FUNC
init_cffi_can_tp(void)
{
  _cffi_init("_cffi_can_tp", 0x2601, &_cffi_type_context);
}
#endif

#ifdef __GNUC__
#  pragma GCC visibility pop
#endif
